/**
 * The structure of a minimap event type.
 */
class MinimapEventType
{
  /**
   * The string value of the type of this minimap event type.
   * @type {string}
   */
  type = 'unset';

  /**
   * The color to render onto the minimap.
   * @type {string}
   */
  color = '#aa66ffcc';

  /**
   * The default shape to render for this minimap event type.
   * Supported: 'disk' | 'square' | 'diamond' | 'plus'
   * @type {string}
   */
  shape = 'disk';

  /**
   * The various shapes that a minimap event marker can be.
   * @type {{Disk: string, Square: string, Diamond: string, Plus: string}}
   */
  static Shapes = {
    Disk: 'disk',
    Square: 'square',
    Diamond: 'diamond',
    Plus: 'plus',
    HollowSquare: 'hollow-square',
  };

  /**
   * The minimap event type of unset, used for when an event explicitly does not have a minimap tag on it.
   * @type {MinimapEventType}
   */
  static Unset = new MinimapEventType('unset', '#99999999', MinimapEventType.Shapes.Disk);

  /**
   * The minimap event type of Player, used for rendering the player onto the minimap.
   * @type {MinimapEventType}
   */
  static Player = new MinimapEventType('player', '#00aaaacc', MinimapEventType.Shapes.Plus);

  /**
   * The minimap event type of Follower, used for rendering your party allies onto the minimap.
   * @type {MinimapEventType}
   */
  static Follower = new MinimapEventType('follower', '#44aaffcc', MinimapEventType.Shapes.Square);

  /**
   * The minimap event type of Enemy, used for rendering hostile combatants onto the minimap.
   * @type {MinimapEventType}
   */
  static EnemyHostile = new MinimapEventType('enemyHostile', '#ff4444cc', MinimapEventType.Shapes.Diamond);

  /**
   * The minimap event type of Inanimate, used for rendering inanimate objects that are backed by an enemy onto the
   * minimap.
   * @type {MinimapEventType}
   */
  static EnemyInanimate = new MinimapEventType('enemyInanimate', '#ffaa44cc', MinimapEventType.Shapes.Diamond);

  /**
   * The minimap event type of NPC, used for various characters that aren't that important.
   * @type {MinimapEventType}
   */
  static Npc = new MinimapEventType('npc', '#dd66ffcc', MinimapEventType.Shapes.Disk);

  /**
   * The minimap event type of loot, used for events generated by loot dropped on the ground.
   * @type {MinimapEventType}
   */
  static Loot = new MinimapEventType('loot', '#44ff66cc', MinimapEventType.Shapes.Diamond);

  /**
   * The minimap event type of object, used for various interactables around the game like doors or levers.
   * @type {MinimapEventType}
   */
  static Object = new MinimapEventType('object', '#dddd00cc', MinimapEventType.Shapes.Diamond);

  /**
   * The minimap event type of teleport, rendered as a hollow square. May stretch if <areaEvent:WxH> is present.
   * @type {MinimapEventType}
   */
  static Teleport = new MinimapEventType('teleport', '#66ccffcc', MinimapEventType.Shapes.HollowSquare);

  /**
   * The minimap event type for quests: offer available (not yet started).
   * @type {MinimapEventType}
   */
  static QuestOffer = new MinimapEventType('questOffer', '#ffdd33cc', MinimapEventType.Shapes.Square);

  /**
   * The minimap event type for quests: can progress the next objective here.
   * @type {MinimapEventType}
   */
  static QuestProgress = new MinimapEventType('questProgress', '#3399ffcc', MinimapEventType.Shapes.Diamond);

  /**
   * The minimap event type for quests: turn-in / about to complete.
   * @type {MinimapEventType}
   */
  static QuestTurnIn = new MinimapEventType('questTurnIn', '#66ff66cc', MinimapEventType.Shapes.Disk);

  constructor(type, color = '#00000066', shape = 'disk')
  {
    this.type = type;
    this.color = color;
    this.shape = shape;
  }
}

//region annoations
/*:
 * @target MZ
 * @plugindesc
 * [v1.0.1 MAP] Renders a passability-driven minimap on the screen.
 * @author JE
 * @url https://github.com/je-can-code/rmmz-plugins
 * @base J-Base
 * @orderAfter J-Base
 * @orderAfter J-ABS
 * @orderAfter J-HUD
 * @orderafter J-TIME
 * @help
 * ============================================================================
 * OVERVIEW
 * This plugin renders a minimap onto the map.
 *
 * Integrates with others of mine plugins:
 * - J-Base; to be honest this is just required for all my plugins.
 * - J-ABS; reveals battlers on the map.
 * - J-HUD; respects "should hide HUD" logic.
 * - J-TIME; visibility syncs with TIME window if available.
 *
 * ----------------------------------------------------------------------------
 * DETAILS:
 * The minimap will render the player, your followers, and if using JABS, it'll
 * also render enemy battlers and any dropped loot.
 *
 * You can use the plugin commands to toggle minimap visibility.
 *
 * ============================================================================
 * PLUGIN PARAMETERS BREAKDOWN:
 * - Minimap X:
 *    Represents the X coordinate this will be rendered at by default.
 *    -1 = will automatically show up at the bottom right.
 * - Minimap Y:
 *    Represents the Y coordinate this will be rendered at by default.
 *    -1 = will automatically show up at the bottom right.
 * - Start Visible:
 *    Whether or not this minimap should be rendered when a game is started.
 *    This state is false by default, and is not persisted into game state.
 * - Respect JABS HUD Visibility:
 *    Whether or not to sync the show/hide toggling with the rest of the JABS
 *    HUD elements.
 * - Overlap Opacity %:
 *    The opacity to switch to when the player overlaps with the minimap.
 *
 * ============================================================================
 * PLUGIN COMMAND BREAKDOWN:
 * - Toggle Minimap:
 *    Choose to show/hide the minimap on-demand.
 *
 * ============================================================================
 * MINIMAP MARKER TAGS
 * Have you ever wanted your minimap to reveal particular events as one of a
 * few categories, like NPCs, loot, or interactable objects? Well now you can!
 * By adding the appropriate tags to the desired events inside a comment event
 * command, you too can have your minimap decorated with additional markers!
 *
 * NOTE ABOUT MARKER TYPES
 * There are multiple marker types that show up on the minimap, here is a
 * brief description of all of them:
 * - Player
 *    The player is usually at the center of the map and has a teal-green
 *    colored plus for its shape.
 * - Follower
 *    The followers of the player are a sky-blue colored smaller squares.
 * - JABS Enemy
 *    These do not show up at all if not using JABS.
 *    They are rendered as red diamond shapes.
 * - NPC
 *    An NPC event marker is rendered as a bright purple circle shape.
 * - Loot
 *    A loot event marker is rendered as a bright green diamond shape.
 * - Interactable Object
 *    An object event marker is rendered as a yellow square shape.
 *
 * If multiple marker tags are present on a single event, the last one
 * found will be prioritized.
 *
 * TAG USAGE:
 * - Events on the map
 *
 * TAG FORMAT:
 *  <minimap:MARKER_TYPE> or <mm:MARKER_TYPE>
 * Where MARKER_TYPE is one of "npc", "loot", or "object" (without quotes).
 *
 * TAG EXAMPLES:
 *  <minimap:npc> or <mm:npc>
 * An event with this tag will show up as an NPC marker on the minimap.
 * 
 *  <minimap:loot> or <mm:loot>
 * An event with this tag will show up as a loot marker on the minimap.
 * 
 *  <minimap:object> or <mm:object>
 * An event with this tag will show up as an object marker on the minimap.
 *
 * ============================================================================
 * CHANGELOG:
 * - 1.0.1
 *    Adds support for JABS-based input remapping.
 * - 1.0.0
 *    The initial release.
 * ============================================================================
 * @param BASEconfigs
 * @text BASE SETUP
 *
 * @param minimapX
 * @parent BASEconfigs
 * @type number
 * @min -1
 * @text Minimap X
 * @desc X position of the minimap in screen pixels; -1 = auto bottom-right.
 * @default -1
 *
 * @param minimapY
 * @parent BASEconfigs
 * @type number
 * @min -1
 * @text Minimap Y
 * @desc Y position of the minimap in screen pixels; -1 = auto bottom-right.
 * @default -1
 *
 * @param startVisible
 * @parent BASEconfigs
 * @type boolean
 * @text Start Visible
 * @desc If true, the minimap starts visible on new game/load.
 * @on Visible
 * @off Hidden
 * @default true
 *
 * @param respectHudHide
 * @parent BASEconfigs
 * @type boolean
 * @text Respect JABS HUD Visibility
 * @desc If true, the minimap hides when the HUD is hidden via input.
 * @on Respect
 * @off Ignore
 * @default true
 *
 * @param overlapOpacityPercent
 * @parent BASEconfigs
 * @type number
 * @min 0
 * @max 100
 * @text Overlap Opacity (%)
 * @desc Minimap alpha when overlapping other windows (0=invisible,100=opaque).
 * @default 40
 *
 *
 * @command toggle-minimap
 * @text Toggle MiniMap
 * @desc Toggles visibility of the minimap to the designated state.
 * @arg action
 * @type boolean
 * @desc True for visible, false for invisible.
 * @default true
 */
//endregion annotations

//region plugin metadata
class J_MAP__PluginMetadata
  extends PluginMetadata
{
  constructor(name, version)
  {
    super(name, version);
  }

  postInitialize()
  {
    super.postInitialize();
    this.initializeMetadata();
  }

  initializeMetadata()
  {
    // Pull parsed plugin parameters from base class.
    const pp = this.parsedPluginParameters ?? {};

    /**
     * The minimap's X position in pixels; -1 = auto bottom-right.
     * @type {number}
     */
    this.minimapX = parseInt(pp['minimapX'] ?? -1);

    /**
     * The minimap's Y position in pixels; -1 = auto bottom-right.
     * @type {number}
     */
    this.minimapY = parseInt(pp['minimapY'] ?? -1);

    /**
     * Start visibility for the minimap on load/new game.
     * @type {boolean}
     */
    this.startVisible = (pp['startVisible'] ?? 'true') === 'true';

    /**
     * If true, the minimap hides when the HUD is hidden via input.
     * @type {boolean}
     */
    this.respectHudHide = (pp['respectHudHide'] ?? 'true') === 'true';

    /**
     * The alpha to use when overlapping other HUD windows (0.0-1.0).
     * @type {number}
     */
    const overlapPct = parseInt(pp['overlapOpacityPercent'] ?? 40);
    this.overlapOpacity = Math.max(0, Math.min(1, overlapPct / 100));
  }
}

//endregion plugin metadata

//region initialization
/**
 * The core where all of my extensions live: in the `J` object.
 */
var J = J || {};

/**
 * The plugin umbrella that governs all things related to this plugin.
 */
J.MAP = {};

/**
 * The plugin umbrella that governs all extensions related to the parent.
 */
J.MAP.EXT ||= {};

/**
 * The metadata associated with this plugin.
 */
J.MAP.Metadata = new J_MAP__PluginMetadata('J-MAP', '1.0.1');

/**
 * A collection of all aliased methods for this plugin.
 */
J.MAP.Aliased = {};
J.MAP.Aliased.DataManager = new Map();
J.MAP.Aliased.Game_Event = new Map();
J.MAP.Aliased.Game_Map = new Map();
J.MAP.Aliased.Game_System = new Map();
J.MAP.Aliased.JABS_Engine = new Map();
J.MAP.Aliased.JABS_StandardController = new Map();
J.MAP.Aliased.Scene_Map = new Map();
J.MAP.Aliased.Window_JabsRemapActions = new Map();

J.MAP.RegExp = {};
J.MAP.RegExp.MinimapEvent = /<(?:mm|minimap):(npc|loot|object|teleport|questOffer|questProgress|questTurnIn)>/gi;
J.MAP.RegExp.BlockMinimap = /<blockMinimap>/gi;
J.MAP.RegExp.AreaEvent = /<areaEvent: ?(\d+)x(\d+)>/i;
//endregion initialization

//region plugin commands
/**
 * Toggle the minimap visibility on the map scene.
 */
PluginManager.registerCommand(J.MAP.Metadata.name, 'toggle-minimap', args =>
{
  const shouldShow = `${args.action}` === 'true';

  // if the map blocks the minimap, force hide and bail.
  if ($gameMap.isMinimapBlocked())
  {
    // ensure the persisted state remains hidden while on this map.
    $gameSystem.hideMinimap();

    // if currently on the map scene, immediately reflect the hidden state.
    if (SceneManager._scene instanceof Scene_Map)
    {
      const miniMap = SceneManager._scene.getMiniMap();
      if (miniMap)
      {
        miniMap.visible = false;
      }
    }

    // do not honor attempts to show while blocked.
    return;
  }

  if (shouldShow)
  {
    $gameSystem.showMinimap();
  }
  else
  {
    $gameSystem.hideMinimap();
  }

  // If we are currently on Scene_Map and have a minimap, update immediately.
  if (SceneManager._scene instanceof Scene_Map)
  {
    const miniMap = SceneManager._scene.getMiniMap();
    if (miniMap)
    {
      miniMap.visible = shouldShow;
    }
  }
});
//endregion plugin commands

//region DataManager
/**
 * Extends/Overrides {@link #createGameObjects}.<br/>
 * Also registers J.MAP minimap input actions and defaults.
 */
J.MAP.Aliased.DataManager.set('createGameObjects', DataManager.createGameObjects);
DataManager.createGameObjects = function()
{
  // perform original logic.
  J.MAP.Aliased.DataManager.get('createGameObjects')
    .call(this);

  // register (or re-register) minimap actions/defaults each boot/load.
  DataManager.registerMinimapInputActions();
};

/**
 * Registers the minimap actions and seeds defaults into the engine-owned Input registry.
 * Called each time game objects are (re)created.
 */
DataManager.registerMinimapInputActions = function()
{
  // register logical actions under the J.MAP namespace.
  Input.registerAction('J.MAP', {
    key: 'minimap-toggle',
    label: 'Toggle Minimap',
    defaults: [ J.ABS.Input.DPadUp ],
    category: 'ui',
  });

  Input.registerAction('J.MAP', {
    key: 'expand-minimap',
    label: 'Expand Minimap (Hold)',
    defaults: [ J.ABS.Input.DPadDown ],
    category: 'ui',
  });

  // seed defaults (replacement-idempotent) and ensure live bindings exist.
  Input.seedDefaultBindings('J.MAP', {
    'minimap-toggle': [ J.ABS.Input.DPadUp ],
    'expand-minimap': [ J.ABS.Input.DPadDown ],
  });
  Input.getAllBindings('J.MAP');
};

//endregion DataManager

//region JABS_Engine
J.MAP.Aliased.JABS_Engine.set('addLootDropToMap', JABS_Engine.prototype.addLootDropToMap);
JABS_Engine.prototype.addLootDropToMap = function(x, y, item)
{
  // Call the most recent/previous implementation (this will respect CA’s Y offset mod, etc.).
  const lootEvent = J.MAP.Aliased.JABS_Engine.get('addLootDropToMap')
    .call(this, x, y, item);

  // If we didn’t get an event for some reason, bail out.
  if (!lootEvent) return lootEvent;

  // Resolve the underlying data event to inject comment commands into.
  const eventId = lootEvent.eventId();
  const eventData = $dataMap.events[eventId];
  if (!eventData) return lootEvent;

  // The single-line comment event command we want to insert.
  const minimapLootComment = {
    code: 108,           // first-line comment
    indent: 0,
    parameters: [ '<mm:loot>' ]
  };

  // grab the first page for adding to.
  const [ firstPage ] = eventData.pages;

  // Prepend so it’s early in the list, but any position works for parsing.
  firstPage.list.unshift(minimapLootComment);

  // Ensure the in-memory Game_Event sees the updated page list and clears minimap caches.
  lootEvent.refresh();

  // return the updated loot event.
  return lootEvent;
};
//endregion JABS_Engine

//region JABS_InputAdapter
// only setup this shortcut key if we're using JABS.
if (J.ABS)
{
  /**
   * Toggles visibility of the minimap on the screen.
   * If J.TIME is used, the visibility will sync with the time window.
   */
  JABS_InputAdapter.performMinimapWindowAction = function()
  {
    // if we cannot toggle the time window, then do not.
    if (!this._canPerformMinimapWindowAction()) return;

    // check if we're using the TIME system.
    if (J.TIME)
    {
      // grab the current TIME window visibility.
      const currentTimeWindowVisibility = $gameTime.isMapWindowVisible();

      // if the visibility is the same, then do nothing.
      if ($gameSystem.isMinimapVisible() === currentTimeWindowVisibility) return;

      // otherwise, set the visibility to whatever the TIME window is now.
      $gameSystem.setMinimapVisibility(currentTimeWindowVisibility);
    }
    else
    {
      // just toggle the visibility.
      $gameSystem.toggleMinimapVisibility();
    }
  };

  /**
   * Determines whether or not the player can toggle the time window.
   * @returns {boolean}
   */
  JABS_InputAdapter._canPerformMinimapWindowAction = function()
  {
    // if the current map blocks the minimap, do not allow toggling at all.
    if ($gameMap.isMinimapBlocked())
    {
      return false;
    }

    return true;
  };

  /**
   * Starts the temporary minimap focus mode (centered, expanded scope).
   */
  JABS_InputAdapter.performMinimapFocusStart = function()
  {
    // if the current map blocks the minimap, do nothing.
    if ($gameMap.isMinimapBlocked()) return;

    // only active on the Map scene.
    if (!(SceneManager._scene instanceof Scene_Map)) return;

    const mini = SceneManager._scene.getMiniMap();
    if (!mini) return;

    // enter focus; sprite method guards repeated calls.
    mini.enterFocusMode();
  };

  /**
   * Ends the temporary minimap focus mode and restores prior size/position.
   */
  JABS_InputAdapter.performMinimapFocusEnd = function()
  {
    // only active on the Map scene.
    if (!(SceneManager._scene instanceof Scene_Map)) return;

    const mini = SceneManager._scene.getMiniMap();
    if (!mini) return;

    // exit focus; sprite method guards if not focused.
    mini.exitFocusMode();
  };
}
//endregion JABS_InputAdapter

//region Game_Event
/**
 * Extends {@link Game_Event.initMembers}.<br>
 * Initializes minimap-related properties.
 */
J.MAP.Aliased.Game_Event.set('initMembers', Game_Event.prototype.initMembers);
Game_Event.prototype.initMembers = function()
{
  // perform original logic.
  J.MAP.Aliased.Game_Event.get('initMembers')
    .call(this);

  /**
   * The J object where all my additional properties live.
   */
  this._j ||= {};

  /**
   * A grouping of all properties associated with minimaps.
   */
  this._j._map ||= {};

  /**
   * The cached event type to display on the minimap.
   * @type {MinimapEventType|null}
   */
  this._j._map._cachedMinimapEventType = null;

  /**
   * The cached check of whether or not to show the event on the minimap.
   * @type {boolean}
   */
  this._j._map._cachedShowOnMinimap = null;
};

/**
 * Sets the type of minimap event this event is.
 * @param {MinimapEventType|null} type The type of minimap event.
 */
Game_Event.prototype.setCachedMinimapEventType = function(type)
{
  this._j._map._cachedMinimapEventType = type;
};

/**
 * Gets the type of minimap event this event is.
 * @returns {MinimapEventType|null}
 */
Game_Event.prototype.getCachedMinimapEventType = function()
{
  return this._j._map._cachedMinimapEventType;
};

/**
 * Sets whether or not to show this event on the minimap.
 * @param {boolean} shouldShow True if this should be shown on the minimap, false otherwise.
 */
Game_Event.prototype.setCachedShowOnMinimap = function(shouldShow)
{
  this._j._map._cachedShowOnMinimap = shouldShow;
};

/**
 * Gets whether or not to show this event on the minimap.
 * @returns {boolean|null}
 */
Game_Event.prototype.getCachedShowOnMinimap = function()
{
  return this._j._map._cachedShowOnMinimap;
};

/**
 * Extends {@link #refresh}.<br/>
 * Also clears the minimap cache forcing the next fetch to recalculate the data.
 */
J.MAP.Aliased.Game_Event.set('refresh', Game_Event.prototype.refresh);
Game_Event.prototype.refresh = function()
{
  // perform original logic.
  J.MAP.Aliased.Game_Event.get('refresh')
    .call(this);

  // refresh the minimap cache..
  this.clearMinimapCache();
};

/**
 * Clears the cache for the minimap data.
 */
Game_Event.prototype.clearMinimapCache = function()
{
  // reset back to default.
  this.setCachedShowOnMinimap(null);
  this.setCachedMinimapEventType(null);
};

/**
 * Determines if it should be shown for this event.
 * @returns {boolean} True if it should be shown, false otherwise.
 */
Game_Event.prototype.shouldShowOnMinimap = function()
{
  // if JABS is enabled, there are a couple other things to evaluate first.
  if (J.ABS)
  {
    // if this is still-collectable loot, then it should be visible.
    if (this.isErased() === false && this.isJabsLoot()) return true;

    // grab the battler if one exists for this event.
    const enemy = this.getJabsBattler();

    // validate we have an enemy before checking enemy things.
    if (enemy)
    {
      // alive and revealed enemies should show on the minimap.
      return (!enemy.isDead() && !enemy.isHidden());
    }
  }

  // check if we have a cached value.
  if (this.getCachedShowOnMinimap() !== null)
  {
    // return the cached value.
    return this.getCachedShowOnMinimap();
  }

  // ensure we have an enemy.
  let shouldShow = false;

  // 1) Explicit minimap type tags on the event comments.
  this.getValidCommentCommands()
    .forEach(command =>
    {
      // shorthand the comment into a variable.
      const [ comment, ] = command.parameters;

      // check if the comment contains a minimap type tag.
      J.MAP.RegExp.MinimapEvent.lastIndex = 0;
      if (J.MAP.RegExp.MinimapEvent.test(comment))
      {
        shouldShow = true;
      }
    });

  // 2) Teleport events (auto-detected from page commands) should be shown.
  if (!shouldShow && this.isTeleportEvent())
  {
    shouldShow = true;
  }

  // 3) Quest events (auto-detected from plugin commands) should be shown.
  if (!shouldShow && this.isQuestEvent())
  {
    shouldShow = true;
  }

  // cache the result for future use.
  this.setCachedShowOnMinimap(shouldShow);

  // return what we found.
  return shouldShow;
};

/**
 * Identify what kind of minimap event type this event is.
 * @returns {MinimapEventType} The type of minimap event.
 */
Game_Event.prototype.minimapEventType = function()
{
  // if JABS is enabled, there are a couple other things to evaluate first.
  if (J.ABS)
  {
    // if this is still-collectable loot, then it should be visible.
    if (this.isErased() === false && this.isJabsLoot()) return MinimapEventType.Loot;

    // grab the battler if one exists for this event.
    const enemy = this.getJabsBattler();

    // validate we have an enemy before checking enemy things.
    if (enemy)
    {
      // dead or hidden enemies don't have an indicator.
      if (enemy.isHidden() || enemy.isDead()) return MinimapEventType.Unset;

      // return the appropriate enemy type marker.
      return enemy.isInanimate()
        ? MinimapEventType.EnemyInanimate
        : MinimapEventType.EnemyHostile;
    }
  }

  // check if we have a cached value.
  if (this.getCachedMinimapEventType() !== null)
  {
    // return the cached value.
    return this.getCachedMinimapEventType();
  }

  // default to hiding the event on the minimap.
  let minimapEventType = MinimapEventType.Unset;

  // check all the valid event commands to see if we have a tag.
  this.getValidCommentCommands()
    .forEach(command =>
    {
      // shorthand the comment into a variable.
      const [ comment, ] = command.parameters;

      // refresh the regex and scan again.
      J.MAP.RegExp.MinimapEvent.lastIndex = 0;
      const match = J.MAP.RegExp.MinimapEvent.exec(comment);

      // if this line doesn't match, then skip it.
      if (!match) return;

      // check the minimap type tag.
      switch (match[1])
      {
        case 'npc':
          minimapEventType = MinimapEventType.Npc;
          break;
        case 'loot':
          minimapEventType = MinimapEventType.Loot;
          break;
        case 'object':
          minimapEventType = MinimapEventType.Object;
          break;
        case 'teleport':
          minimapEventType = MinimapEventType.Teleport;
          break;
        case 'questOffer':
          minimapEventType = MinimapEventType.QuestOffer;
          break;
        case 'questProgress':
          minimapEventType = MinimapEventType.QuestProgress;
          break;
        case 'questTurnIn':
          minimapEventType = MinimapEventType.QuestTurnIn;
          break;
      }
    });

  // Auto-detect quest plugin commands if still unset or to refine to a higher-priority quest state.
  // Priority: TurnIn > Progress > Offer.
  if (this.hasQuestPluginCommand([ "finalize-quest" ]))
  {
    minimapEventType = MinimapEventType.QuestTurnIn;
  }
  // only elevate to progress if not already a higher-priority type.
  else if ((minimapEventType === MinimapEventType.Unset || minimapEventType === MinimapEventType.QuestOffer)
    && this.hasQuestPluginCommand([ "progress-quest" ]))
  {
    minimapEventType = MinimapEventType.QuestProgress;
  }

  // only set to offer if nothing else determined yet.
  if (minimapEventType === MinimapEventType.Unset && this.hasQuestPluginCommand([ "unlock-quests" ]))
  {
    minimapEventType = MinimapEventType.QuestOffer;
  }

  // Auto-detect: if still unset and the page contains a transfer command, treat as teleport.
  if (minimapEventType === MinimapEventType.Unset && this.isTeleportEvent())
  {
    minimapEventType = MinimapEventType.Teleport;
  }

  // cache the result for future use.
  this.setCachedMinimapEventType(minimapEventType);

  // return what we found.
  return minimapEventType;
};

/**
 * Determines whether this event’s current page contains a transfer (teleport) action.
 * @returns {boolean}
 */
Game_Event.prototype.isTeleportEvent = function()
{
  // pull the current page’s command list.
  const list = this.getEventCommandList();

  // command code 201 is "Transfer Player" in RMMZ event commands.
  const hasTransfer = !!list.find(cmd => cmd && cmd.code === 201);

  return !!hasTransfer;
};

/**
 * Determines whether this event's current page contains any quest-related plugin commands.
 * @returns {boolean}
 */
Game_Event.prototype.isQuestEvent = function()
{
  // if not using the omniquest plugin, then its not a quest event.
  if (!J.OMNI || !J.OMNI.EXT || !J.OMNI.EXT.QUEST) return false;

  // return if any of the quest commands are present.
  return this.hasQuestPluginCommand([ "unlock-quests", "progress-quest", "finalize-quest" ]);
};

/**
 * Determines whether or not one or more plugin commands are present by their name in an event.
 * @param {string[]} commandNames The plugin command names to seek.
 * @returns {boolean}
 */
Game_Event.prototype.hasQuestPluginCommand = function(commandNames)
{
  // if not using the omniquest plugin, then the event does not have any quest plugin commands.
  if (!J.OMNI || !J.OMNI.EXT || !J.OMNI.EXT.QUEST) return false;

  // find any matching plugin command.
  const found = this.hasPluginCommand(J.OMNI.EXT.QUEST.Metadata.name, commandNames);

  // return whether we found a matching command.
  return found;
};

/**
 * Parses and returns the area rectangle for this event from <areaEvent:WxH>.
 * Defaults to 1x1 when not present or invalid.
 * @returns {{w:number,h:number}}
 */
Game_Event.prototype.getAreaEventRect = function()
{
  // default area is a single tile.
  let w = 1;
  let h = 1;

  // iterate comments for the area tag.
  const commands = this.getValidCommentCommands();
  for (let i = 0; i < commands.length; i++)
  {
    const [ comment, ] = commands[i].parameters;
    if (!comment) continue;

    J.MAP.RegExp.AreaEvent.lastIndex = 0;
    const match = J.MAP.RegExp.AreaEvent.exec(comment);
    if (match)
    {
      const [ , unparsedW, unparsedH ] = match;
      w = Math.max(1, parseInt(unparsedW));
      h = Math.max(1, parseInt(unparsedH));
      break;
    }
  }

  return {
    w,
    h
  };
};
//endregion Game_Event

//region Game_Map
/**
 * Checks whether the current map blocks the minimap via note tag.
 * @returns {boolean}
 */
Game_Map.prototype.isMinimapBlocked = function()
{
  // Reset regex last index and test.
  J.MAP.RegExp.BlockMinimap.lastIndex = 0;

  // return what we found.
  return J.MAP.RegExp.BlockMinimap.test(this.note() ?? '');
};
//endregion Game_Map

//region Game_System
/**
 * Extends {@link #initMembers}.<br/>
 * Also seeds persistent minimap state.
 */
J.MAP.Aliased.Game_System.set('initMembers', Game_System.prototype.initMembers);
Game_System.prototype.initMembers = function()
{
  // original
  J.MAP.Aliased.Game_System.get('initMembers').call(this);

  /**
   * The shared root namespace for all J-plugins temporary data.
   */
  this._j ||= {};

  /**
   * A grouping of all properties associated with the map/minimap plugin.
   */
  this._j._map ||= {};

  /**
   * Current desired minimap visibility.
   * @type {boolean}
   */
  this._j._map._minimapVisible = J.MAP.Metadata.startVisible;
};

/**
 * Get whether the minimap should be visible (before HUD auto-hide rules).
 */
Game_System.prototype.isMinimapVisible = function()
{
  return this._j._map._minimapVisible;
};

/**
 * Show the minimap.
 */
Game_System.prototype.showMinimap = function()
{
  this._j._map._minimapVisible = true;
};

/**
 * Hide the minimap.
 */
Game_System.prototype.hideMinimap = function()
{
  this._j._map._minimapVisible = false;
};

/**
 * Toggles to the opposite of the current visibility for the minimap.
 */
Game_System.prototype.toggleMinimapVisibility = function()
{
  this._j._map._minimapVisible = !this._j._map._minimapVisible;
};

/**
 * Sets visibility of the minimap to the given value.
 */
Game_System.prototype.setMinimapVisibility = function(visibility)
{
  this._j._map._minimapVisible = visibility;
};

/**
 * Extends {@link #onAfterLoad}.<br/>
 * Also handles the possibility of loading a save that was created before using this plugin.
 */
J.MAP.Aliased.Game_System.set('onAfterLoad', Game_System.prototype.onAfterLoad);
Game_System.prototype.onAfterLoad = function()
{
  // perform original logic.
  J.MAP.Aliased.Game_System.get('onAfterLoad').call(this);

  // ensure structure and default if missing from older saves.
  this._j ||= {};
  this._j._map ||= {};
  this._j._map._minimapVisible ??= J.MAP.Metadata.startVisible;
};
//endregion Game_System

//region JABS_InputController
if (J.ABS)
{
  /**
   * Extends/Overrides {@link #initMembers}.<br/>
   * Also initializes the minimap controller-local state without lazy init.
   */
  J.MAP.Aliased.JABS_StandardController.set('initMembers', JABS_StandardController.prototype.initMembers);
  JABS_StandardController.prototype.initMembers = function()
  {
    // perform original logic.
    const original = J.MAP.Aliased.JABS_StandardController.get('initMembers')
      .call(this);

    // initialize the previously-lazy field for minimap focus tracking.
    this._minimapFocusPressedPrev = false;

    // return whatever the original returned, if anything.
    return original;
  };

  /**
   * Gets whether or not the expand-minimap action was pressed in the prior frame.
   * @returns {boolean}
   */
  JABS_StandardController.prototype.getMinimapFocusPressedPrev = function()
  {
    // return the prior pressed state.
    return this._minimapFocusPressedPrev === true;
  };

  /**
   * Sets whether or not the expand-minimap action was pressed in the prior frame.
   * @param {boolean} v The new pressed state.
   */
  JABS_StandardController.prototype.setMinimapFocusPressedPrev = function(v)
  {
    // set the prior pressed state.
    this._minimapFocusPressedPrev = v === true;
  };

  /**
   * Extends {@link #update}.<br/>
   * Also handles input detection for the the minimap window toggle shortcut key.
   */
  J.MAP.Aliased.JABS_StandardController.set('update', JABS_StandardController.prototype.update);
  JABS_StandardController.prototype.update = function()
  {
    // perform original logic.
    J.MAP.Aliased.JABS_StandardController.get('update')
      .call(this);

    // update input for the time window toggle shortcut key.
    this.updateMiniMapWindowAction();

    // update input for the hold-to-peek focus (MobilitySkill).
    this.updateMinimapFocusPeekAction();
  };

  /**
   * Monitors and takes action based on player input regarding the minimap window toggle shortcut key.
   */
  JABS_StandardController.prototype.updateMiniMapWindowAction = function()
  {
    // check if the action's input requirements have been met.
    if (this.isMiniMapWindowActionTriggered())
    {
      // execute the action.
      this.performMiniMapWindowAction();
    }
  };

  /**
   * Checks the inputs of the minimap window action.
   * @returns {boolean}
   */
  JABS_StandardController.prototype.isMiniMapWindowActionTriggered = function()
  {
    // this action requires the registered minimap toggle to be triggered (edge).
    if (Input.isActionTriggered('J.MAP', 'minimap-toggle'))
    {
      return true;
    }

    // input was not triggered.
    return false;
  };

  /**
   * Executes the time window toggle action.
   */
  JABS_StandardController.prototype.performMiniMapWindowAction = function()
  {
    JABS_InputAdapter.performMinimapWindowAction();
  };

  /**
   * Handles press-and-hold on the MobilitySkill input to show a centered, expanded minimap.
   * On press: enter focus mode; on release: exit focus mode.
   */
  JABS_StandardController.prototype.updateMinimapFocusPeekAction = function()
  {
    // do not allow if the current map blocks the minimap entirely.
    if ($gameMap.isMinimapBlocked()) return;

    // edge: pressed this frame → start focus.
    if (this.isMinimapFocusPeekActionHeld())
    {
      this.performMinimapFocusStart();
    }

    // edge: released this frame → end focus.
    if (this.isMinimapFocusPeekActionLifted())
    {
      this.performMinimapFocusEnd();
    }

    // persist press state for the registered expand-minimap action.
    this.setMinimapFocusPressedPrev(Input.isActionPressed('J.MAP', 'expand-minimap'));
  };

  JABS_StandardController.prototype.isMinimapFocusPeekActionHeld = function()
  {
    // edge: newly pressed this frame.
    if (Input.isActionPressed('J.MAP', 'expand-minimap') && this.getMinimapFocusPressedPrev() === false)
    {
      return true;
    }

    // not newly pressed.
    return false;
  };

  JABS_StandardController.prototype.isMinimapFocusPeekActionLifted = function()
  {
    // edge: just released this frame.
    if (Input.isActionPressed('J.MAP', 'expand-minimap') === false && this.getMinimapFocusPressedPrev() === true)
    {
      return true;
    }

    // not released this frame.
    return false;
  };

  /**
   * Begins the minimap focus mode.
   */
  JABS_StandardController.prototype.performMinimapFocusStart = function()
  {
    JABS_InputAdapter.performMinimapFocusStart();
  };

  /**
   * Ends the minimap focus mode.
   */
  JABS_StandardController.prototype.performMinimapFocusEnd = function()
  {
    JABS_InputAdapter.performMinimapFocusEnd();
  };
}
//endregion JABS_InputController

//region Scene_Map
/**
 * Extends {@link #initMembers}.<br/>
 * Also initializes the minimap-related members.
 */
J.MAP.Aliased.Scene_Map.set('initMembers', Scene_Map.prototype.initMembers);
Scene_Map.prototype.initMembers = function()
{
  // perform original logic.
  J.MAP.Aliased.Scene_Map.get('initMembers')
    .call(this);

  // also initialize the HUD members.
  this.initMiniMapMembers();
};

/**
 * Initializes the minimap-related members.
 */
Scene_Map.prototype.initMiniMapMembers = function()
{
  /**
   * The J object where all my additional properties live.
   */
  this._j ||= {};

  /**
   * A grouping of all properties associated with this plugin.
   */
  this._j._map ||= {};

  /**
   * The tracked minimap.
   * @type {Sprite_MiniMap}
   */
  this._j._map._miniMap = null;
};

/**
 * Extends {@link #createAllWindows}.<br>
 * Also creates the minimap sprite.
 */
J.MAP.Aliased.Scene_Map.set('createAllWindows', Scene_Map.prototype.createAllWindows);
Scene_Map.prototype.createAllWindows = function()
{
  // perform original logic
  J.MAP.Aliased.Scene_Map.get('createAllWindows')
    .call(this);

  // create the minimap layer
  this.createMiniMap();
};

/**
 * Creates and attaches the minimap to the scene.
 */
Scene_Map.prototype.createMiniMap = function()
{
  /**
   * The minimap sprite instance.
   * @type {Sprite_MiniMap}
   */
  this._j._map._miniMap = new Sprite_MiniMap();

  // set initial visibility from runtime state.
  let shouldBeVisible = $gameSystem.isMinimapVisible();

  // if this map blocks the minimap, force hide regardless of saved preference.
  if ($gameMap.isMinimapBlocked())
  {
    shouldBeVisible = false;
  }

  // apply the computed visibility.
  this._j._map._miniMap.visible = shouldBeVisible;

  // add the minimap to the scene.
  this.addChild(this._j._map._miniMap);
};

/**
 * Gets the minimap sprite.
 * @returns {Sprite_MiniMap|null}
 */
Scene_Map.prototype.getMiniMap = function()
{
  return this._j._map._miniMap;
};

/**
 * Extends {@link #update}.<br/>
 * Also keeps the visibility of the minimap in sync.
 */
J.MAP.Aliased.Scene_Map.set('update', Scene_Map.prototype.update);
Scene_Map.prototype.update = function()
{
  // perform original logic.
  J.MAP.Aliased.Scene_Map.get('update')
    .call(this);

  // handle minimap visibility.
  this.updateMiniMapVisibilityAndOpacity();
};

/**
 * Manages minimap visibility and overlap-opacity per frame.
 */
Scene_Map.prototype.updateMiniMapVisibilityAndOpacity = function()
{
  // grab the minimap for visibility work.
  const miniMap = this.getMiniMap();
  if (!miniMap) return; // nothing to do if no minimap exists.

  // 0) Per-map block wins immediately.
  if ($gameMap.isMinimapBlocked())
  {
    // if blocked, force hide and skip any further processing.
    miniMap.visible = false;
    return;
  }

  // If the minimap is in focus mode, force it visible and full alpha and skip dimming.
  if (miniMap.isInFocusMode())
  {
    miniMap.visible = true;
    miniMap.alpha = 1.0;
    return;
  }

  // 1) Start with runtime toggle from Game_System.
  let shouldBeVisible = $gameSystem.isMinimapVisible();

  // 2) Respect HUD hide (JABS input) if configured.
  if (J.HUD && J.MAP.Metadata.respectHudHide && !$hudManager.canShowHud())
  {
    shouldBeVisible = false;
  }

  // apply visibility based on toggles.
  miniMap.visible = shouldBeVisible;
  if (!miniMap.visible) return; // if hidden, no need to compute overlap alpha.

  // 3) Overlap-opacity against the player.
  const overlapping = this.hasMinimapInterference();
  const overlapAlpha = J.MAP.Metadata.overlapOpacity ?? 0.40; // sensible default if no param yet.
  miniMap.alpha = overlapping
    ? overlapAlpha
    : 1.0;
};

/**
 * Determine if the minimap overlaps with the player.
 * @returns {boolean}
 */
Scene_Map.prototype.hasMinimapInterference = function()
{
  const mini = this.getMiniMap();
  if (!mini || !mini.bitmap) return false;

  // Minimap bounds (Sprite anchored center).
  const mmW = mini.bitmap.width;
  const mmH = mini.bitmap.height;
  const mmLeft = Math.round(mini.x - (mmW / 2));
  const mmTop = Math.round(mini.y - (mmH / 2));
  const mmRight = mmLeft + mmW;
  const mmBottom = mmTop + mmH;

  // Player screen-space rectangle. The engine’s screenX/screenY gives the
  // character’s foot position; use tile size as a reasonable sprite bbox.
  const px = $gamePlayer.screenX();
  const py = $gamePlayer.screenY();
  const pW = ($gameMap.tileWidth && $gameMap.tileWidth()) || 48;
  const pH = ($gameMap.tileHeight && $gameMap.tileHeight()) || 48;

  // Approximate player rect: centered horizontally, extends up one tile.
  const pLeft = Math.round(px - (pW / 2));
  const pTop = Math.round(py - pH);
  const pRight = pLeft + pW;
  const pBottom = pTop + pH;

  // AABB overlap check
  const noOverlap = (mmRight <= pLeft) || (mmLeft >= pRight) || (mmBottom <= pTop) || (mmTop >= pBottom);
  return !noOverlap;
};
//endregion Scene_Map

//region Sprite_MiniMap
// noinspection JSBitwiseOperatorUsage
/**
 * A lightweight, cached mini-map sprite:
 * - Builds a padded cache of the map background and impassability edges.
 * - Renders the current view window by blitting from the cache.
 * - Draws dynamic overlay markers each frame (enemies, followers).
 * - Draws the player marker (green circle) onto the base bitmap when the viewport changes.
 *
 * External environment and global dependencies (RPG Maker MZ + JABS):
 * - $gameMap: Game_Map
 * - $gamePlayer: Game_Player
 * - Graphics: PIXI / RM screen dimensions
 * - Bitmap: RMMZ Bitmap
 * - Sprite: RMMZ Sprite
 * - J.ABS, JABS_AiManager: JABS battle system (optional)
 */
class Sprite_MiniMap
  extends Sprite
{
  //region configuration

  /**
   * Number of tiles to show from the player in each direction.
   * Viewport width/height in tiles = (MAP_RANGE * 2 + 1).
   * @type {number}
   */
  MAP_RANGE = 12;

  /**
   * The pixel size of each minimap tile.
   * @type {number}
   */
  SCALE = 8;

  /**
   * Minimap X position in screen pixels; -1 = auto bottom-right.
   * @type {number}
   */
  POS_X = -1;

  /**
   * Minimap Y position in screen pixels; -1 = auto bottom-right.
   * @type {number}
   */
  POS_Y = -1;

  /**
   * Background color surrounding/behind the minimap.
   * Accepts #rrggbb or #rrggbbaa; converted to CSS via toCss().
   * @type {string}
   */
  BG_COLOR = '#00000066';

  /**
   * General floor/ground fill color.
   * @type {string}
   */
  FLOOR_COLOR = '#ffffff33';

  /**
   * Edge (directional block) stroke color.
   * @type {string}
   */
  EDGE_COLOR = '#e6f0ffcc';

  /**
   * Fill color for wholly impassable tiles (blocked in all directions).
   * @type {string}
   */
  IMPASSABLE_COLOR = '#330000aa';

  /**
   * Minimum marker size in pixels.
   * @type {number}
   */
  MARKER_MIN = 2;

  /**
   * Whether or not to use smooth scrolling for the map rather than tile-step based scrolling.
   * @type {boolean}
   */
  SMOOTH_SCROLL = true;

  /**
   * The smoothness of scrolling- use 0 to follow the real position, or decimal for a little drag.
   * @type {number}
   */
  SMOOTH_LERP = 0;

  //endregion configuration

  /**
   * Constructs a new minimap sprite and initializes the cache, overlay, and positioning.
   */
  constructor()
  {
    super();

    this.initCoreData();
    this.initCacheData();
    this.initOverlayLayer();
    this.initChromeLayer();
    this.initFrameLayer();
  }

  initCoreData()
  {
    /**
     * The number of padding tiles applied on each side of the cached map.
     * This is equal to MAP_RANGE and allows player-centered scrolling near edges.
     * @type {number}
     */
    this._cacheOffsetTiles = 0;

    /**
     * Viewport dimension, in tiles, along a single axis (width or height).
     * Computed as (MAP_RANGE * 2 + 1).
     * @type {number}
     */
    this._viewTiles = (this.MAP_RANGE * 2) + 1;

    /**
     * Viewport width in pixels.
     * @type {number}
     */
    this._width = this._viewTiles * this.SCALE;

    /**
     * Viewport height in pixels.
     * @type {number}
     */
    this._height = this._viewTiles * this.SCALE;

    /**
     * The displayed bitmap containing only the visible window (cache slice + player marker).
     * @type {Bitmap}
     */
    this.bitmap = new Bitmap(this._width, this._height);

    // Positioning
    this.anchor.set(0.5, 0.5);

    this.x = J.MAP.Metadata.minimapX >= 0
      ? J.MAP.Metadata.minimapX
      : (Graphics.boxWidth - (this._width / 2) - 10);

    this.y = J.MAP.Metadata.minimapY >= 0
      ? J.MAP.Metadata.minimapY
      : (Graphics.boxHeight - (this._height / 2) - 10);

    this.z = 200;

    /**
     * Last known player x tile; used to detect when to re-blit the window.
     * @type {number}
     */
    this._lastX = -1;

    /**
     * Last known player y tile; used to detect when to re-blit the window.
     * @type {number}
     */
    this._lastY = -1;
  }

  initCacheData()
  {
    /**
     * Full-map cached bitmap (map + padding around it), rebuilt per-map.
     * @type {Bitmap}
     */
    this._cacheBitmap = new Bitmap(1, 1);

    /**
     * Whether the full-map cache is currently built.
     * @type {boolean}
     */
    this._cacheReady = false;

    /**
     * The mapId associated with the current cache.
     * @type {number}
     */
    this._cachedMapId = 0;

    this._smoothFx = 0; // smoothed source X in pixels within _cacheBitmap
    this._smoothFy = 0; // smoothed source Y in pixels within _cacheBitmap
  }

  initOverlayLayer()
  {
    /**
     * Dynamic overlay bitmap drawn every frame (enemies, followers, etc.).
     * @type {Bitmap}
     */
    this._overlay = new Bitmap(this._width, this._height);

    /**
     * Sprite child for the overlay bitmap.
     * @type {Sprite}
     */
    this._overlaySprite = new Sprite(this._overlay);
    this._overlaySprite.anchor.set(0.5, 0.5);
    this.addChild(this._overlaySprite);
  }

  initChromeLayer()
  {
    // Create a chrome layer (static UI chrome, like the North notch)
    this._chromeBitmap = new Bitmap(this._width, this._height);
    this._chromeSprite = new Sprite(this._chromeBitmap);

    // Add this line to align the chrome with the minimap center
    this._chromeSprite.anchor.set(0.5, 0.5);

    // adds it as the final layer before the frame.
    this.addChild(this._chromeSprite);

    // Draw the chrome now.
    this.redrawChrome();
  }

  initFrameLayer()
  {
    /**
     * The minimap's frame sprite.
     * @type {Sprite}
     */
    this._minimapFrameSprite = new Sprite(new Bitmap(this._width, this._height));
    this._minimapFrameSprite.anchor.set(0.5, 0.5);
    this._minimapFrameSprite.x = 0; // or align to minimap container offsets
    this._minimapFrameSprite.y = 0;
    this.addChild(this._minimapFrameSprite);

    // Draw initial frame
    this.drawPixelArtMinimapFrame(
      this._minimapFrameSprite.bitmap,
      0,
      0,
      this._minimapFrameSprite.bitmap.width,
      this._minimapFrameSprite.bitmap.height,
      {
        // tweak to taste
        thickness: 3,
        rim: 1,
        highlight: 1, // palette options (examples)
      });
  }

  //region lifecycle
  /**
   * Flags the full-map cache to be rebuilt on the next update tick.
   * Useful when tileset or rendering settings change.
   */
  refresh()
  {
    this._cacheReady = false;
  }

  /**
   * Per-frame update. Ensures cache is built for the active map,
   * re-blits the visible window when the player has changed tiles,
   * and refreshes the overlay every frame.
   */
  update()
  {
    super.update();
    if (!$gameMap) return;

    const mapId = $gameMap.mapId
      ? $gameMap.mapId()
      : 0;

    // Build cache if first time, or map changed, or refresh() requested.
    if (!this._cacheReady || this._cachedMapId !== mapId)
    {
      this.buildCache();
      this._cachedMapId = mapId;
      this._cacheReady = true;

      // Seed smoothing so there's no snap on the first frame after rebuild.
      const {
        fx,
        fy
      } = this.srcFloatFromPlayer?.() ?? {
        fx: 0,
        fy: 0
      };
      this._smoothFx = fx;
      this._smoothFy = fy;

      // Force initial redraw regardless of movement.
      this._lastX = -99999;
      this._lastY = -99999;
    }

    if (this.SMOOTH_SCROLL)
    {
      // Always redraw to follow sub-tile movement
      this.redrawWindowSmooth();
      this.refreshMinimapFrame();

      // Keep last integer tile updated for any logic that relies on it
      this._lastX = $gamePlayer.x;
      this._lastY = $gamePlayer.y;
    }
    else if (this.needsUpdate())
    {
      // Legacy: only redraw when the player changes tiles
      this.redrawWindow();
      this._lastX = $gamePlayer.x;
      this._lastY = $gamePlayer.y;
      this.refreshMinimapFrame();
    }

    // Overlay is dynamic; draw every frame.
    this.redrawOverlay();
  }

  refreshMinimapFrame()
  {
    if (!this._minimapFrameSprite) return;

    const w = this.bitmap.width;
    const h = this.bitmap.height;
    if (this._minimapFrameSprite.bitmap.width !== w || this._minimapFrameSprite.bitmap.height !== h)
    {
      this._minimapFrameSprite.bitmap = new Bitmap(w, h);
      // Keep the sprite centered over the parent
      this._minimapFrameSprite.anchor.set(0.5, 0.5);
      this._minimapFrameSprite.x = 0;
      this._minimapFrameSprite.y = 0;
    }
    else
    {
      this._minimapFrameSprite.bitmap.clear();
    }

    this.drawPixelArtMinimapFrame(this._minimapFrameSprite.bitmap, 0, 0, w, h);
  }

  //endregion lifecycle

  /**
   * Enters a temporary focus mode: the minimap is moved to the middle-right of the screen and greatly expand scope.
   * While focused, overlap dimming is disabled and the map is always visible.
   * Calling this while already focused is a no-op.
   */
  enterFocusMode()
  {
    // if already focused, do nothing.
    if (this._focusMode) return;

    // mark focused.
    this._focusMode = true;

    // snapshot current state to restore later.
    this._preFocusState = {
      mapRange: this.MAP_RANGE,           // current tiles in each direction
      scale: this.SCALE,                  // current tile pixel size
      width: this._width,                 // window width in px
      height: this._height,               // window height in px
      x: this.x,                          // position
      y: this.y,
      smoothFx: this._smoothFx,           // smooth scroll floats
      smoothFy: this._smoothFy,
    };

    // Choose an expanded scope. 2x is a good default; tweak to taste.
    // We expand MAP_RANGE (more tiles) to see far more of the map at once.
    const focusMultiplier = 3; // show twice the tiles in each direction
    this.MAP_RANGE = Math.max(4, Math.floor(this.MAP_RANGE * focusMultiplier));

    // Optionally nudge SCALE up a hair so the whole widget is even larger
    // (comment out if you want strictly “more area” with same per-tile size).
    // this.SCALE = this.SCALE + 2;

    // Recompute derived dimensions for the new window size.
    this._viewTiles = (this.MAP_RANGE * 2) + 1; // tiles per axis
    this._width = this._viewTiles * this.SCALE; // pixels
    this._height = this._viewTiles * this.SCALE; // pixels

    // Resize the base bitmap.
    this.bitmap = new Bitmap(this._width, this._height);

    // Resize overlay and keep it centered/aligned.
    if (this._overlaySprite)
    {
      this._overlay = new Bitmap(this._width, this._height);
      this._overlaySprite.bitmap = this._overlay;
      this._overlaySprite.anchor.set(0.5, 0.5);
    }

    // Resize chrome and redraw.
    if (this._chromeSprite)
    {
      this._chromeBitmap = new Bitmap(this._width, this._height);
      this._chromeSprite.bitmap = this._chromeBitmap;
      this._chromeSprite.anchor.set(0.5, 0.5);
      this.redrawChrome();
    }

    // Resize and redraw frame to match.
    this.refreshMinimapFrame();

    // Reposition: center of the screen.
    this.x = Math.floor(Graphics.boxWidth - (this._width / 2) - 10);
    this.y = Math.floor(Graphics.boxHeight / 2);

    // Force cache rebuild and seed smoothing so there is no snap.
    this.refresh();
    const {
      fx,
      fy
    } = this.srcFloatFromPlayer?.() ?? {
      fx: 0,
      fy: 0
    };
    this._smoothFx = fx;
    this._smoothFy = fy;

    // Ensure immediate redraw.
    this._lastX = -99999;
    this._lastY = -99999;

    // Ensure visibility while focused.
    this.visible = true;
  }

  /**
   * Exits focus mode and restores the previous minimap size, scope, and position.
   * Calling this when not focused is a no-op.
   */
  exitFocusMode()
  {
    // if not focused, nothing to do.
    if (!this._focusMode) return;

    // clear focus flag first to let visibility logic work normally.
    this._focusMode = false;

    // pull prior state; if missing, just bail gracefully.
    const st = this._preFocusState || null;
    this._preFocusState = null;
    if (!st) return;

    // Restore core values.
    this.MAP_RANGE = st.mapRange;
    this.SCALE = st.scale;

    // Recompute derived window size.
    this._viewTiles = (this.MAP_RANGE * 2) + 1;
    this._width = this._viewTiles * this.SCALE;
    this._height = this._viewTiles * this.SCALE;

    // Resize base bitmap.
    this.bitmap = new Bitmap(this._width, this._height);

    // Resize overlay bitmap/sprite.
    if (this._overlaySprite)
    {
      this._overlay = new Bitmap(this._width, this._height);
      this._overlaySprite.bitmap = this._overlay;
      this._overlaySprite.anchor.set(0.5, 0.5);
    }

    // Resize chrome and redraw.
    if (this._chromeSprite)
    {
      this._chromeBitmap = new Bitmap(this._width, this._height);
      this._chromeSprite.bitmap = this._chromeBitmap;
      this._chromeSprite.anchor.set(0.5, 0.5);
      this.redrawChrome();
    }

    // Refresh the frame to match new size.
    this.refreshMinimapFrame();

    // Restore configured corner/coordinates.
    this.anchor.set(0.5, 0.5);
    this.x = J.MAP.Metadata.minimapX >= 0
      ? J.MAP.Metadata.minimapX
      : (Graphics.boxWidth - (this._width / 2) - 10);
    this.y = J.MAP.Metadata.minimapY >= 0
      ? J.MAP.Metadata.minimapY
      : (Graphics.boxHeight - (this._height / 2) - 10);

    // Force cache rebuild for the smaller window and reset smoothing.
    this.refresh();
    const {
      fx,
      fy
    } = this.srcFloatFromPlayer?.() ?? {
      fx: 0,
      fy: 0
    };
    this._smoothFx = fx;
    this._smoothFy = fy;

    // Force redraw next update.
    this._lastX = -99999;
    this._lastY = -99999;
  }

  /**
   * Whether the minimap is in the temporary focus mode.
   * @returns {boolean}
   */
  isInFocusMode()
  {
    return !!this._focusMode;
  }

  //region drawing
  /**
   * Returns true if the player changed tiles since the last redraw.
   * @returns {boolean}
   */
  needsUpdate()
  {
    if (!$gamePlayer) return false;
    return $gamePlayer.x !== this._lastX || $gamePlayer.y !== this._lastY;
  }

  /**
   * Rebuilds the full cached bitmap of the map (with padding), drawing:
   * - Background
   * - Base floor tiles
   * - Edge strokes according to passability flags
   * Subclasses may override drawCell(...) to fully customize tile rendering.
   */
  buildCache()
  {
    const mapWidth = $gameMap.width();
    const mapHeight = $gameMap.height();

    const pad = this.MAP_RANGE; // padding tiles around the map in the cache
    this._cacheOffsetTiles = pad;

    const cacheTilesW = mapWidth + (pad * 2);
    const cacheTilesH = mapHeight + (pad * 2);
    const pixelWidth = cacheTilesW * this.SCALE;
    const pixelHeight = cacheTilesH * this.SCALE;

    this._cacheBitmap = new Bitmap(pixelWidth, pixelHeight);

    // Background behind the map
    this._cacheBitmap.fillRect(0, 0, pixelWidth, pixelHeight, this.toCss(this.BG_COLOR));

    // Pre-fetch tileset flags once
    /** @type {number[]} */
    const flags = $gameMap.tilesetFlags();

    // Loop flags from engine
    const loopH = $gameMap.isLoopHorizontal?.() ?? false;
    const loopV = $gameMap.isLoopVertical?.() ?? false;

    // Base map at (pad, pad)
    this.drawMapCopyAt(pad, pad, flags);

    // Horizontal wrapping (fill left/right padding)
    if (loopH)
    {
      this.drawMapCopyAt(pad - mapWidth, pad, flags); // left band
      this.drawMapCopyAt(pad + mapWidth, pad, flags); // right band
    }

    // Vertical wrapping (fill top/bottom padding)
    if (loopV)
    {
      this.drawMapCopyAt(pad, pad - mapHeight, flags); // top band
      this.drawMapCopyAt(pad, pad + mapHeight, flags); // bottom band
    }

    // Corner quadrants when both loop
    if (loopH && loopV)
    {
      this.drawMapCopyAt(pad - mapWidth, pad - mapHeight, flags); // top-left
      this.drawMapCopyAt(pad + mapWidth, pad - mapHeight, flags); // top-right
      this.drawMapCopyAt(pad - mapWidth, pad + mapHeight, flags); // bottom-left
      this.drawMapCopyAt(pad + mapWidth, pad + mapHeight, flags); // bottom-right
    }
  }

  /**
   * Clears the base window bitmap and blits the appropriate slice
   * from the full cached bitmap, then draws the player marker at the center.
   */
  redrawWindow()
  {
    if (!this._cacheBitmap) return;

    this.bitmap.clear();

    const {
      srcX,
      srcY
    } = this.cacheSrcFromPlayer();
    this.bitmap.blt(this._cacheBitmap, srcX, srcY, this._width, this._height, 0, 0);
    // Player marker at center (green circle)
    this.drawPlayerMarker();
  }

  /**
   * Draws the static layer after the overlay layer.
   */
  redrawChrome()
  {
    if (!this._chromeBitmap) return;

    this._chromeBitmap.clear();
    this.drawNorthNotch(this._chromeBitmap);

    this.setChildIndex(this._chromeSprite, this.children.length - 1);
  }

  /**
   * Clears and redraws the dynamic overlay (enemies, followers, etc.).
   */
  redrawOverlay()
  {
    this._overlay.clear();
    this.drawOverlay(this._overlay);
  }

  redrawWindowSmooth()
  {
    if (!this._cacheBitmap) return;

    // Target float source (pixels)
    const {
      fx: tfx,
      fy: tfy
    } = this.srcFloatFromPlayer();

    // Optional easing (lerp) for extra smoothness
    if (this.SMOOTH_LERP > 0)
    {
      const a = this.SMOOTH_LERP;
      this._smoothFx = this._smoothFx + (tfx - this._smoothFx) * a;
      this._smoothFy = this._smoothFy + (tfy - this._smoothFy) * a;
    }
    else
    {
      this._smoothFx = tfx;
      this._smoothFy = tfy;
    }

    // Clamp source to cache bounds
    const maxSx = Math.max(0, this._cacheBitmap.width - this._width);
    const maxSy = Math.max(0, this._cacheBitmap.height - this._height);
    const sfx = Math.min(Math.max(this._smoothFx, 0), maxSx);
    const sfy = Math.min(Math.max(this._smoothFy, 0), maxSy);

    // Slice on whole pixels; keep sub-pixel via dest offset
    const srcX = Math.floor(sfx);
    const srcY = Math.floor(sfy);
    const dx = -(sfx - srcX); // fractional remainder, negative to keep player centered
    const dy = -(sfy - srcY);

    this.bitmap.clear();

    // If your runtime floors dx/dy, wrap with Math.round(dx/dy)
    this.bitmap.blt(this._cacheBitmap, srcX, srcY, this._width, this._height, dx, dy);

    // Player marker stays at center
    this.drawPlayerMarker();
  }

  /**
   * Draws the player marker (a centered plus "+") at the center tile
   * of the current window on the base bitmap.
   */
  drawPlayerMarker()
  {
    // Center tile (MAP_RANGE, MAP_RANGE) in window space
    const {
      leftPx,
      topPx
    } = this.tileLeftTopPx(this.MAP_RANGE, this.MAP_RANGE);

    // Base player marker (plus)
    this.drawPlusOn(this.bitmap, leftPx, topPx, this.SCALE - 2, MinimapEventType.Player.color);

    // Perpendicular facing line (always on)
    const dir = $gamePlayer.direction();
    this.drawFacingPerpLineOn(this.bitmap, leftPx, topPx, this.SCALE, MinimapEventType.Player.color, dir);
  }

  /**
   * Draws edge strokes for a single tile according to the blocked-direction bitmask.
   * Bits: 0x01=down, 0x02=left, 0x04=right, 0x08=up
   * @param {Bitmap} targetBitmap - The bitmap to draw onto.
   * @param {number} sx - Tile top-left x in pixels on targetBitmap.
   * @param {number} sy - Tile top-left y in pixels on targetBitmap.
   * @param {number} mask - Blocked-direction mask.
   */
  drawEdges(targetBitmap, sx, sy, mask)
  {
    const c = this.toCss(this.EDGE_COLOR);
    const s = this.SCALE;
    const t = 2; // edge thickness

    if (mask & 0x01) targetBitmap.fillRect(sx, sy + s - t, s, t, c); // bottom
    if (mask & 0x02) targetBitmap.fillRect(sx, sy, t, s, c);         // left
    if (mask & 0x04) targetBitmap.fillRect(sx + s - t, sy, t, s, c); // right
    if (mask & 0x08) targetBitmap.fillRect(sx, sy, s, t, c);         // top
  }

  /**
   * Draws one full map copy into the cache, offset by whole-tile origins.
   * originTileX/Y are in cache tile space, relative to the cache’s (0,0).
   * @param {number} originTileX
   * @param {number} originTileY
   * @param {number[]} flags - tileset flags (pre-fetched)
   */
  drawMapCopyAt(originTileX, originTileY, flags)
  {
    const mapWidth = $gameMap.width();
    const mapHeight = $gameMap.height();

    for (let y = 0; y < mapHeight; y++)
    {
      for (let x = 0; x < mapWidth; x++)
      {
        const sx = (originTileX + x) * this.SCALE;
        const sy = (originTileY + y) * this.SCALE;

        const mask = this.blockedMaskAt(x, y, flags);

        if (this.drawCell(x, y, sx, sy, mask)) continue;

        if (mask === 0x0f)
        {
          this._cacheBitmap.fillRect(sx, sy, this.SCALE, this.SCALE, this.toCss(this.IMPASSABLE_COLOR));
        }
        else
        {
          this._cacheBitmap.fillRect(sx, sy, this.SCALE, this.SCALE, this.toCss(this.FLOOR_COLOR));
          this.drawEdges(this._cacheBitmap, sx, sy, mask);
        }
      }
    }
  }

  /**
   * Draws a marker using a {@link MinimapEventType}'s shape and color.
   */
  drawByType(targetBitmap, lx, ly, sizePx, type)
  {
    const size = Math.max(this.MARKER_MIN, Math.min(this.SCALE, sizePx));
    switch (type.shape)
    {
      case MinimapEventType.Shapes.Square:
        this.drawSquareOn(targetBitmap, lx, ly, size, type.color);
        break;
      case MinimapEventType.Shapes.Diamond:
        this.drawDiamondOn(targetBitmap, lx, ly, size, type.color);
        break;
      case MinimapEventType.Shapes.Plus:
        this.drawPlusOn(targetBitmap, lx, ly, size, type.color);
        break;
      case MinimapEventType.Shapes.HollowSquare:
        this.drawHollowSquareOn(targetBitmap, lx, ly, size, type.color);
        break;
      case MinimapEventType.Shapes.Disk:
      default:
        this.drawDiskOn(targetBitmap, lx, ly, size, type.color);
        break;
    }
  }

  drawNorthNotch(targetBitmap)
  {
    const w = this._width;
    const centerX = Math.floor(w / 2);

    // Use your configured edge color with a darker halo for contrast
    const fillCol = this.toCss(this.EDGE_COLOR);     // e.g., '#ffffff77'
    const underCol = 'rgba(0,0,0,0.40)';             // subtle dark halo

    // Height scales with tile size, clamped (≈4–7 px for common scales)
    const triH = Math.max(4, Math.min(7, Math.floor(this.SCALE / 2)));

    // Inset from top to sit below any outer border lines
    const topY = 6; // increase to 6–8 if your border is thicker

    // Underlay halo (slightly wider than the fill)
    for (let i = 0; i < triH; i++)
    {
      const span = i + 1;
      const y = topY + i;
      targetBitmap.fillRect(centerX - span - 1, y, (span * 2 + 1) + 2, 1, underCol);
    }

    // Fill: symmetric, up-pointing isosceles triangle
    for (let i = 0; i < triH; i++)
    {
      const span = i;
      const y = topY + i;
      targetBitmap.fillRect(centerX - span, y, span * 2 + 1, 1, fillCol);
    }
  }

  //endregion drawing

  //region overlay & markers
  /**
   * Draws dynamic markers for enemies and followers onto the overlay bitmap.
   * - Hostile enemies: red diamonds.
   * - Inanimate/non-hostile enemies: orange diamonds.
   * - Followers: blue squares.
   * @param {Bitmap} overlayBitmap - The overlay bitmap to draw on.
   */
  drawOverlay(overlayBitmap)
  {
    if (!$gameMap || !$gamePlayer) return;

    this.drawFollowers(overlayBitmap);
    this.drawEvents(overlayBitmap);
  }

  /**
   * Draws the followers onto the overlay bitmap.
   */
  drawFollowers(overlayBitmap)
  {
    const scale = this.SCALE;

    const followers = $gamePlayer.followers()
      .visibleFollowers();

    followers.forEach(follower =>
    {
      const wx = (follower._realX ?? follower.x);
      const wy = (follower._realY ?? follower.y);
      const {
        lx,
        ly
      } = this.worldToLocalAroundPlayer(wx, wy);
      if (!this.inView(lx, ly)) return;

      this.drawByType(overlayBitmap, lx, ly, Math.max(2, scale - 4), MinimapEventType.Follower);
    }, this);
  }

  /**
   * Draws the various events onto the overlay bitmap.
   */
  drawEvents(overlayBitmap)
  {
    $gameMap.events()
      .forEach(event => this.drawEvent(overlayBitmap, event), this);
  }

  /**
   * Draws a particular event onto the bitmap overlay.
   * @param {Bitmap} overlayBitmap The bitmap being rendered onto.
   * @param {Game_Event} event The event potentially being rendered onto the map.
   */
  drawEvent(overlayBitmap, event)
  {
    if (!this.isEventRenderable(event)) return;

    const wx = (event._realX ?? event.x);
    const wy = (event._realY ?? event.y);
    const {
      lx,
      ly
    } = this.worldToLocalAroundPlayer(wx, wy);
    if (!this.inView(lx, ly)) return;

    const type = event.minimapEventType();

    // Special handling for teleport markers with area.
    if (type === MinimapEventType.Teleport)
    {
      const {
        w,
        h
      } = event.getAreaEventRect();

      // if the area is more than 1x1, draw a stretched rectangle covering the area footprint.
      if (w > 1 || h > 1)
      {
        // Compute area in local pixels; assume event tile is the top-left of the area.
        const areaWpx = Math.max(1, Math.floor(w * this.SCALE));
        const areaHpx = Math.max(1, Math.floor(h * this.SCALE));

        // adaptive outline thickness.
        const t = Math.max(1, Math.floor(this.SCALE / 6));
        const outlineCol = this.toCss(type.color);

        // Build a softer matching fill color.
        const fillCol = this.fillCssFrom(type.color, 0.35);

        // Outline rectangle: top / bottom / left / right
        overlayBitmap.fillRect(lx, ly, areaWpx, t, outlineCol);                    // top edge
        overlayBitmap.fillRect(lx, ly + areaHpx - t, areaWpx, t, outlineCol);     // bottom edge
        overlayBitmap.fillRect(lx, ly, t, areaHpx, outlineCol);                    // left edge
        overlayBitmap.fillRect(lx + areaWpx - t, ly, t, areaHpx, outlineCol);      // right edge

        // Inner fill (inside outline), if large enough.
        const innerW = areaWpx - t * 2;
        const innerH = areaHpx - t * 2;
        if (innerW > 0 && innerH > 0)
        {
          overlayBitmap.fillRect(lx + t, ly + t, innerW, innerH, fillCol);
        }

        // skip the per-tile marker when area outline/fill was drawn.
        return;
      }

      // 1x1 teleport area: draw a single outlined square with soft fill.
      this.drawByType(overlayBitmap, lx, ly, Math.max(2, this.SCALE - 4), type);
      return;
    }

    // All other marker types draw normally per-tile.
    this.drawByType(overlayBitmap, lx, ly, Math.max(2, this.SCALE - 4), type);
  }

  /**
   * Returns true if the upper-left pixel of a tile (lx, ly) falls within the visible window bounds.
   * Accepts coordinates that may be slightly outside to avoid drawing off-screen.
   * @param {number} lx - Local x in pixels (tile origin).
   * @param {number} ly - Local y in pixels (tile origin).
   * @returns {boolean}
   */
  inView(lx, ly)
  {
    const s = this.SCALE;
    return !(lx < -s || ly < -s || lx >= this._width || ly >= this._height);
  }

  /**
   * Computes the centered inner box within one tile for a marker of a given size.
   * @param {number} sizePx - Desired marker size in pixels (clamped to [MARKER_MIN..SCALE]).
   * @returns {{size:number, ox:number, oy:number, r:number}} Object containing:
   * - size: clamped size in pixels
   * - ox: left offset inside the tile
   * - oy: top offset inside the tile
   * - r: radius/falloff (floor(size/2)), useful for disks/diamonds
   */
  innerBox(sizePx)
  {
    const s = this.SCALE;
    const size = Math.max(this.MARKER_MIN, Math.min(s, Math.floor(sizePx)));
    const ox = Math.floor((s - size) / 2);
    const oy = Math.floor((s - size) / 2);
    const r = Math.floor(size / 2);
    return {
      size,
      ox,
      oy,
      r
    };
  }

  /**
   * Converts world tile coordinates (may be fractional for smooth movement)
   * to local window pixel coordinates (tile top-left).
   * @param {number} wx - World x in tiles (can be fractional).
   * @param {number} wy - World y in tiles (can be fractional).
   * @param {number} leftTile - Current window's top-left world tile X.
   * @param {number} topTile - Current window's top-left world tile Y.
   * @returns {{lx:number, ly:number}} Local pixel coords.
   */
  worldToLocal(wx, wy, leftTile, topTile)
  {
    const s = this.SCALE;
    return {
      lx: Math.floor((wx - leftTile) * s),
      ly: Math.floor((wy - topTile) * s),
    };
  }

  /**
   * Converts an in-window tile coordinate (0..viewTiles-1) to the pixel top-left in the bitmap.
   * @param {number} tx - Tile X within the window.
   * @param {number} ty - Tile Y within the window.
   * @returns {{leftPx:number, topPx:number}}
   */
  tileLeftTopPx(tx, ty)
  {
    const s = this.SCALE;
    return {
      leftPx: tx * s,
      topPx: ty * s
    };
  }

  /**
   * Draws a filled disk (circle) centered inside the tile at (lx, ly).
   * @param {Bitmap} targetBitmap - Target bitmap to draw on.
   * @param {number} lx - Tile top-left x in pixels.
   * @param {number} ly - Tile top-left y in pixels.
   * @param {number} sizePx - Desired marker size in pixels.
   * @param {string} color - Hex or hex+alpha string (e.g., #rrggbb or #rrggbbaa).
   */
  drawDiskOn(targetBitmap, lx, ly, sizePx, color)
  {
    if (!this.inView(lx, ly)) return;
    const {
      ox,
      oy,
      r
    } = this.innerBox(sizePx);
    const cx = lx + ox + r;
    const cy = ly + oy + r;
    const col = this.toCss(color);

    for (let dy = -r; dy <= r; dy++)
    {
      const span = Math.floor(Math.sqrt(r * r - dy * dy));
      targetBitmap.fillRect(cx - span, cy + dy, span * 2 + 1, 1, col);
    }
  }

  /**
   * Draws a filled diamond (rotated square) centered inside the tile at (lx, ly).
   * @param {Bitmap} targetBitmap - Target bitmap to draw on.
   * @param {number} lx - Tile top-left x in pixels.
   * @param {number} ly - Tile top-left y in pixels.
   * @param {number} sizePx - Desired marker size in pixels.
   * @param {string} color - Hex or hex+alpha string (e.g., #rrggbb or #rrggbbaa).
   */
  drawDiamondOn(targetBitmap, lx, ly, sizePx, color)
  {
    if (!this.inView(lx, ly)) return;
    const {
      ox,
      oy,
      r
    } = this.innerBox(sizePx);
    const cx = lx + ox + r;
    const cy = ly + oy + r;
    const col = this.toCss(color);

    for (let dy = -r; dy <= r; dy++)
    {
      const span = r - Math.abs(dy);
      targetBitmap.fillRect(cx - span, cy + dy, span * 2 + 1, 1, col);
    }
  }

  /**
   * Draws a filled square centered inside the tile at (lx, ly).
   * @param {Bitmap} targetBitmap - Target bitmap to draw on.
   * @param {number} lx - Tile top-left x in pixels.
   * @param {number} ly - Tile top-left y in pixels.
   * @param {number} sizePx - Desired marker size in pixels.
   * @param {string} color - Hex or hex+alpha string (e.g., #rrggbb or #rrggbbaa).
   */
  drawSquareOn(targetBitmap, lx, ly, sizePx, color)
  {
    if (!this.inView(lx, ly)) return;
    const {
      size,
      ox,
      oy
    } = this.innerBox(sizePx);
    targetBitmap.fillRect(lx + ox, ly + oy, size, size, this.toCss(color));
  }

  /**
   * Draws a centered plus "+" inside the tile at (lx, ly).
   * The plus scales with sizePx and uses an adaptive arm thickness.
   * @param {Bitmap} targetBitmap - Target bitmap to draw on.
   * @param {number} lx - Tile top-left x in pixels.
   * @param {number} ly - Tile top-left y in pixels.
   * @param {number} sizePx - Desired marker size in pixels.
   * @param {string} color - Hex or hex+alpha string (e.g., #rrggbb or #rrggbbaa).
   */
  drawPlusOn(targetBitmap, lx, ly, sizePx, color)
  {
    if (!this.inView(lx, ly)) return;

    // Compute the centered inner box and the tile center.
    const {
      size,
      ox,
      oy,
      r
    } = this.innerBox(sizePx);
    const cx = lx + ox + r;
    const cy = ly + oy + r;
    const col = this.toCss(color);

    // Adaptive thickness: about one third of the marker size (min 1px).
    const thickness = Math.max(1, Math.floor(size / 3));
    const halfT = Math.floor(thickness / 2);

    // Vertical arm (full height of the marker box), centered on cx.
    const vLeft = cx - halfT;
    const vTop = ly + oy;
    targetBitmap.fillRect(vLeft, vTop, thickness, size, col);

    // Horizontal arm (full width of the marker box), centered on cy.
    const hLeft = lx + ox;
    const hTop = cy - halfT;
    targetBitmap.fillRect(hLeft, hTop, size, thickness, col);
  }

  /**
   * Draws a hollow square or series of squares based on the given size.
   * @param {Bitmap} targetBitmap - Target bitmap to draw on.
   * @param {number} lx - Tile top-left x in pixels.
   * @param {number} ly - Tile top-left y in pixels.
   * @param {number} sizePx - Desired marker size in pixels.
   * @param {string} color - Hex or hex+alpha string (e.g., #rrggbb or #rrggbbaa).
   */
  drawHollowSquareOn(targetBitmap, lx, ly, sizePx, color)
  {
    // Render a 1px (or 2px for larger scales) outline square centered in the tile, with a soft fill for contrast.
    if (!this.inView(lx, ly)) return;

    // compute inner centered box.
    const {
      size: s,
      ox,
      oy
    } = this.innerBox(sizePx);
    const x0 = lx + ox;
    const y0 = ly + oy;
    const w = s;
    const h = s;

    // adaptive outline thickness.
    const t = Math.max(1, Math.floor(this.SCALE / 6));

    // Outline color (as provided).
    const outlineCol = this.toCss(color);

    // Compute the fill color.
    const fillCol = this.fillCssFrom(color, 0.35);

    // Draw outline: top, bottom, left, right.
    // top
    targetBitmap.fillRect(x0, y0, w, t, outlineCol);
    // bottom
    targetBitmap.fillRect(x0, y0 + h - t, w, t, outlineCol);
    // left
    targetBitmap.fillRect(x0, y0, t, h, outlineCol);
    // right
    targetBitmap.fillRect(x0 + w - t, y0, t, h, outlineCol);

    // Draw inner fill (inside the outline). Guard tiny sizes.
    const innerW = w - t * 2;
    const innerH = h - t * 2;
    if (innerW > 0 && innerH > 0)
    {
      targetBitmap.fillRect(x0 + t, y0 + t, innerW, innerH, fillCol);
    }
  }

  /**
   * Draws a small flat line ("T-cap") perpendicular to the plus arm for the
   * player's facing direction. The line sits near the tip of the faced arm
   * and stays within the inner marker box to avoid clipping.
   *
   * @param {Bitmap} targetBitmap
   * @param {number} lx - tile top-left x in pixels
   * @param {number} ly - tile top-left y in pixels
   * @param {number} sizePx - desired marker size in pixels
   * @param {string} color - hex or hex+alpha (#rrggbb or #rrggbbaa)
   * @param {number} dir - facing direction (2=down,4=left,6=right,8=up)
   */
  drawFacingPerpLineOn(targetBitmap, lx, ly, sizePx, color, dir)
  {
    if (!this.inView(lx, ly)) return;

    // Compute inner box and center.
    const {
      size,
      ox,
      oy,
      r
    } = this.innerBox(sizePx);
    const cx = lx + ox + r;
    const cy = ly + oy + r;
    const col = this.toCss(color);

    // Inner box bounds (inclusive)
    const ix0 = lx + ox;
    const iy0 = ly + oy;
    const ix1 = ix0 + size - 1;
    const iy1 = iy0 + size - 1;

    // Match the plus arm thickness for harmony, but make the cap a bit slimmer.
    const thickness = Math.max(2, Math.floor(size / 3));
    const capThickness = Math.max(1, Math.floor(thickness / 2));

    // Cap length scales with size, clamped to look good and avoid overhangs.
    const capLen = Math.max(thickness + 1, Math.min(size - 2, Math.floor(size * 0.6)));

    // 1px margin from inner box edge.
    const margin = 1;

    switch (dir)
    {
      case 8:
      { // Up: faced arm vertical; draw a horizontal line near top.
        const y = iy0 + margin;
        const x = cx - Math.floor(capLen / 2);
        targetBitmap.fillRect(x, y, capLen, capThickness, col);
        break;
      }
      case 2:
      { // Down: horizontal line near bottom.
        const y = iy1 - margin - (capThickness - 1);
        const x = cx - Math.floor(capLen / 2);
        targetBitmap.fillRect(x, y, capLen, capThickness, col);
        break;
      }
      case 4:
      { // Left: faced arm horizontal; draw a vertical line near left edge.
        const x = ix0 + margin;
        const y = cy - Math.floor(capLen / 2);
        targetBitmap.fillRect(x, y, capThickness, capLen, col);
        break;
      }
      case 6:
      { // Right: vertical line near right edge.
        const x = ix1 - margin - (capThickness - 1);
        const y = cy - Math.floor(capLen / 2);
        targetBitmap.fillRect(x, y, capThickness, capLen, col);
        break;
      }
      default:
        break;
    }
  }

  //endregion overlay & markers

  //region passability
  /**
   * Computes the blocked-direction mask for a tile using the same precedence
   * as Game_Map.prototype.checkPassage.
   * Bits:
   * - 0x01 = down blocked
   * - 0x02 = left blocked
   * - 0x04 = right blocked
   * - 0x08 = up blocked
   * 0x0f indicates wholly impassable.
   * @param {number} x - Tile X.
   * @param {number} y - Tile Y.
   * @param {number[]} [flagsRef] - Optional pre-fetched tilesetFlags array.
   * @returns {number} The blocked-direction mask.
   */
  blockedMaskAt(x, y, flagsRef)
  {
    if (!$gameMap.isValid(x, y)) return 0x0f; // treat OOB as blocked

    const flags = flagsRef || $gameMap.tilesetFlags();
    const tiles = $gameMap.allTiles(x, y); // tile-graphic events first, then layers 3..0

    for (const tileId of tiles)
    {
      const flag = flags[tileId] || 0;
      if (flag & 0x10) continue; // star: no effect on passage
      return flag & 0x0f;        // lower nibble: directional blocks
    }

    // No decisive tile found → engine defaults to blocked for our purposes
    return 0x0f;
  }

  //endregion passability

  //region utilities
  /**
   * Converts #rrggbb or #rrggbbaa into a CSS color string.
   * @param {string} hex - Hex color string (#rrggbb or #rrggbbaa). Whitespace is ignored.
   * @returns {string} CSS color string.
   */
  toCss(hex)
  {
    if (typeof hex !== 'string') return '#ff00ff';
    const clean = hex.replace(/\s+/g, '');
    if (!clean.startsWith('#')) return '#ff00ff';

    if (clean.length === 7) return clean; // #rrggbb

    if (clean.length === 9)
    { // #rrggbbaa
      const r = parseInt(clean.slice(1, 3), 16);
      const g = parseInt(clean.slice(3, 5), 16);
      const b = parseInt(clean.slice(5, 7), 16);
      const a = parseInt(clean.slice(7, 9), 16) / 255;
      return `rgba(${r},${g},${b},${a})`;
    }

    return '#ff00ff'; // error/magenta
  }

  fillCssFrom(hex, ratio = 0.35)
  {
    // strip leading '#'.
    const raw = (hex && hex[0] === '#')
      ? hex.slice(1)
      : (hex ?? "");

    // parse rgb from #rrggbb or #rrggbbaa.
    const r = parseInt(raw.slice(0, 2) || "00", 16);
    const g = parseInt(raw.slice(2, 4) || "00", 16);
    const b = parseInt(raw.slice(4, 6) || "00", 16);
    const a = raw.length >= 8
      ? (parseInt(raw.slice(6, 8), 16) / 255)
      : 1;

    // scale the original alpha to a gentler fill (default ~35% of outline alpha).
    const fillA = Math.max(0, Math.min(1, a * ratio));

    // return rgba css string.
    return `rgba(${r},${g},${b},${fillA.toFixed(3)})`;
  }

  /**
   * Computes the top-left pixel in the padded cache to blit from,
   * based on the player's current tile position (kept centered).
   * @returns {{srcX:number, srcY:number}}
   */
  cacheSrcFromPlayer()
  {
    const pad = this._cacheOffsetTiles; // tiles
    const srcX = (($gamePlayer.x - this.MAP_RANGE) + pad) * this.SCALE;
    const srcY = (($gamePlayer.y - this.MAP_RANGE) + pad) * this.SCALE;
    return {
      srcX,
      srcY
    };
  }

  srcFloatFromPlayer()
  {
    const pad = this._cacheOffsetTiles; // tiles
    const rx = ($gamePlayer._realX ?? $gamePlayer.x);
    const ry = ($gamePlayer._realY ?? $gamePlayer.y);
    // Top-left of window so player is centered (MAP_RANGE from origin)
    const fx = ((rx - this.MAP_RANGE) + pad) * this.SCALE; // pixels
    const fy = ((ry - this.MAP_RANGE) + pad) * this.SCALE; // pixels
    return {
      fx,
      fy
    };
  }

  /**
   * Converts world tile coords to local overlay pixel coords using the shortest
   * wrapped delta around the player. Ensures markers near map seams appear on
   * the closest side in looping maps.
   * @param {number} wx - World x in tiles (can be fractional).
   * @param {number} wy - World y in tiles (can be fractional).
   * @returns {{lx:number, ly:number}}
   */
  worldToLocalAroundPlayer(wx, wy)
  {
    const s = this.SCALE;

    // Player precise position (smooth if available)
    const px = ($gamePlayer._realX ?? $gamePlayer.x);
    const py = ($gamePlayer._realY ?? $gamePlayer.y);

    let dx = wx - px;
    let dy = wy - py;

    const loopH = $gameMap.isLoopHorizontal();
    const loopV = $gameMap.isLoopVertical();
    const mapW = $gameMap.width();
    const mapH = $gameMap.height();

    // Choose shortest horizontal delta on looped maps
    if (loopH && mapW > 0)
    {
      if (dx > mapW / 2) dx -= mapW;
      if (dx < -mapW / 2) dx += mapW;
    }

    // Choose shortest vertical delta on looped maps
    if (loopV && mapH > 0)
    {
      if (dy > mapH / 2) dy -= mapH;
      if (dy < -mapH / 2) dy += mapH;
    }

    // Center tile is MAP_RANGE; offset by deltas
    const tileX = this.MAP_RANGE + dx;
    const tileY = this.MAP_RANGE + dy;

    return {
      lx: Math.floor(tileX * s),
      ly: Math.floor(tileY * s),
    };
  }

  /**
   * Returns whether an event should be rendered on the minimap.
   * @param {Game_Event} event The event being inspected for rendering as an overlay on the minimap.
   */
  isEventRenderable(event)
  {
    if (!event) return false;

    // Skip erased events.
    if (event.isErased()) return false;

    // skip transparent events.
    if (event.isTransparent()) return false;

    // Only show normal priority (same as characters) by default.
    // TODO: monitor this to see if we need to apply any of this type of filtering.
    // if (event.isNormalPriority() === false) return false;

    // return whether or not the event should be shown on the minimap.
    return event.shouldShowOnMinimap();
  }

  //endregion utilities

  //region hooks
  /**
   * Hook for subclasses to fully override how a single map cell is drawn into the cache.
   * Return true to indicate you handled drawing for this cell; false to use default rendering.
   * @param {number} x - Map tile X.
   * @param {number} y - Map tile Y.
   * @param {number} sx - Pixel x origin within the cache bitmap (top-left of the tile).
   * @param {number} sy - Pixel y origin within the cache bitmap (top-left of the tile).
   * @param {number} blockedMask - Directional block mask for this tile.
   * @returns {boolean} True if the tile was fully handled; false to fall back to default rendering.
   */
  // eslint-disable-next-line no-unused-vars
  drawCell(x, y, sx, sy, blockedMask)
  {
    // Example override:
    // if ($gameMap.regionId(x, y) === 50) { /* draw special */ return true; }
    return false;
  }

  /**
   * Computes the top-left world tile (x, y) for the visible window (no clamping).
   * The cached bitmap has padding, so un-clamped values are safe to render.
   * @returns {[number, number]} Tuple [leftTile, topTile].
   */
  currentViewOrigin()
  {
    const half = this.MAP_RANGE;
    const leftTile = $gamePlayer.x - half;
    const topTile = $gamePlayer.y - half;
    return [ leftTile, topTile ];
  }

  //endregion hooks

  //region border
  /**
   * Draw a pixel-art frame onto a bitmap.
   * - bitmap: target Bitmap (already sized to the minimap area or overlay).
   * - x, y, w, h: frame rectangle.
   * - opts: colors and thickness options.
   */
  drawPixelArtMinimapFrame(bitmap, x, y, w, h, opts = {})
  {
    // Configurable palette and sizes
    const thickness = opts.thickness ?? 3;       // main frame thickness
    const rim = opts.rim ?? 1;              // outer darker rim thickness
    const hl = opts.highlight ?? 1;        // inner bright highlight thickness

    // Colors (ARGB hex or CSS strings), tuned to look nice on most maps
    const cDark = opts.cDark ?? "rgba(18,18,22,1.0)";  // outer rim (nearly black)
    const cMid = opts.cMid ?? "rgba(255,220,180,0.3)";  // body of the frame
    const cInner = opts.cInner ?? "rgba(200,200,220,1.0)"; // inner highlight ring
    const cShadow = opts.cShadow ?? "rgba(0,0,0,0.35)";    // soft drop shadow
    const cAccent = opts.cAccent ?? "rgba(255,215,120,1.0)"; // small corner rivets (gold-ish)

    // Soft shadow outside the frame for depth (optional)
    const sh = 2; // shadow size
    // top
    bitmap.fillRect(x - sh, y - sh, w + sh * 2, sh, cShadow);
    // bottom
    bitmap.fillRect(x - sh, y + h, w + sh * 2, sh, cShadow);
    // left
    bitmap.fillRect(x - sh, y, sh, h, cShadow);
    // right
    bitmap.fillRect(x + w, y, sh, h, cShadow);

    // Outer rim
    // top
    bitmap.fillRect(x, y, w, rim, cDark);
    // bottom
    bitmap.fillRect(x, y + h - rim, w, rim, cDark);
    // left
    bitmap.fillRect(x, y, rim, h, cDark);
    // right
    bitmap.fillRect(x + w - rim, y, rim, h, cDark);

    // Main body (between rim and inner highlight)
    const innerX = x + rim;
    const innerY = y + rim;
    const innerW = w - rim * 2;
    const innerH = h - rim * 2;

    // top band
    bitmap.fillRect(innerX, innerY, innerW, thickness, cMid);
    // bottom band
    bitmap.fillRect(innerX, innerY + innerH - thickness, innerW, thickness, cMid);
    // left band
    bitmap.fillRect(innerX, innerY, thickness, innerH, cMid);
    // right band
    bitmap.fillRect(innerX + innerW - thickness, innerY, thickness, innerH, cMid);

    // Inner highlight ring (subtle)
    const ihX = innerX + thickness;
    const ihY = innerY + thickness;
    const ihW = innerW - thickness * 2;
    const ihH = innerH - thickness * 2;

    if (ihW > 0 && ihH > 0)
    {
      // top
      bitmap.fillRect(ihX, ihY, ihW, hl, cInner);
      // left
      bitmap.fillRect(ihX, ihY, hl, ihH, cInner);

      // Slightly dimmer highlight on bottom/right for a beveled look
      const cInner2 = "rgba(180,180,200,0.9)";
      // bottom
      bitmap.fillRect(ihX, ihY + ihH - hl, ihW, hl, cInner2);
      // right
      bitmap.fillRect(ihX + ihW - hl, ihY, hl, ihH, cInner2);
    }

    // Corner accents/rivets (tiny dots)
    const dot = 2;
    const pad = 3;

    // top-left
    bitmap.fillRect(x + pad, y + pad, dot, dot, cAccent);
    // top-right
    bitmap.fillRect(x + w - pad - dot, y + pad, dot, dot, cAccent);
    // bottom-left
    bitmap.fillRect(x + pad, y + h - pad - dot, dot, dot, cAccent);
    // bottom-right
    bitmap.fillRect(x + w - pad - dot, y + h - pad - dot, dot, dot, cAccent);
  }

  //endregion border
}

//endregion Sprite_MiniMap

//region Window_JabsRemapActions
/**
 * Extends/Overrides {@link #buildPostExtensionGroups}.<br/>
 * Also appends a "Map Actions" section for external (J.MAP) actions.
 * @param {BuiltWindowCommand[]} rows The rows being built.
 * @param {Set<string>} can The set of assignable logical action keys.
 */
J.MAP.Aliased.Window_JabsRemapActions.set(
  'buildPostExtensionGroups',
  Window_JabsRemapActions.prototype.buildPostExtensionGroups
);
Window_JabsRemapActions.prototype.buildPostExtensionGroups = function(rows, can)
{
  // perform original logic (default: no-op).
  J.MAP.Aliased.Window_JabsRemapActions
    .get("buildPostExtensionGroups")
    .call(this, rows, can);

  // append a header for the minimap actions.
  rows.push(this.buildHeaderCommand("Map Actions"));

  // add external actions for the minimap with fixed per-action icons (feature glyphs).
  rows.push(this.buildExternalActionCommand("J.MAP", "minimap-toggle", "Toggle Minimap", 190));
  rows.push(this.buildExternalActionCommand("J.MAP", "expand-minimap", "Expand Minimap (Hold)", 2480));
};
//endregion Window_JabsRemapActions