/*:
 * @target MZ
 * @plugindesc 
 * [v3.0 JABS] Data structure of an action event generated by the JABS engine.
 * @author JE
 * @url https://github.com/je-can-code/rmmz
 * @base J-ABS
 * @help
 * ============================================================================
 * A component of JABS.
 * This class represents the binding of a skill execution to an event.
 * Effectively, these are generated for each action executed (such as a
 * sword swing or a fireball spell).
 * ============================================================================
 */

/**
 * An object that binds a `Game_Action` to a `Game_Event` on the map.
 */
class JABS_Action {
  /**
   * The minimum duration a `JABS_Action` must exist visually before cleaning it up.
   * 
   * All actions should exist visually for at least 8 frames.
   * @returns {8} The minimum number of frames, 8.
   */
  static getMinimumDuration() {
    return 8;
  };

  /**
   * @constructor
   * @param {string} uuid This action's unique identifier.
   * @param {rm.types.Skill} baseSkill The skill retrieved from `$dataSkills[id]`. 
   * @param {number} teamId A shorthand for the team id this skill belongs to.
   * @param {Game_Action} gameAction The underlying action associated with this `JABS_Action`.
   * @param {JABS_Battler} caster The `JABS_Battler` who created this `JABS_Action`.
   * @param {boolean} isRetaliation Whether or not this is a retaliation action.
   * @param {number} direction The direction this action will face initially.
   * @param {string?} cooldownKey Whether or not this is a direct action.
   */
  constructor({ uuid, baseSkill, teamId, gameAction, caster, isRetaliation, direction, cooldownKey }) {
    /**
     * The unique identifier for this action.
     * 
     * All actions that are bound to an event have this.
     * @type {string}
     */
    this._uuid = uuid;
    /**
     * The base skill object, in case needed for something.
     * @type {rm.types.Skill}
     */
    this._baseSkill = baseSkill;

    /**
     * The team the owner of this skill is a part of.
     * @type {number}
     */
    this._teamId = teamId;

    /**
     * The `Game_Action` to bind to the `Game_Event` and `JABS_Battler`.
     * @type {Game_Action}
     */
    this._gameAction = gameAction;

    /**
     * The `JABS_Battler` that used created this `JABS_Action`. 
     * @type {JABS_Battler}
     */
    this._caster = caster;

    /**
     * Whether or not this action was generated as a retaliation to another battler's action.
     * @type {boolean}
     */
    this._isRetaliation = isRetaliation;

    /**
     * The direction this projectile will initially face and move.
     * @type {number}
     */
    this._facing = direction;

    /**
     * The type of action this is. Used for mapping cooldowns to the appropriate slot on the caster.
     * @type {string}
     */
    this._actionCooldownType = cooldownKey ?? "global";

    this.initMembers();
  }

  /**
   * Initializes all properties on this class.
   */
   initMembers() {
    /**
     * The JABS metadata associated with the base skill.
     * Almost all custom feature flags live inside this object.
     * @type {JABS_SkillData}
     */
    this._jabsData = this._baseSkill._j;

    /**
     * The current timer on this particular action.
     * @type {number}
     */
    this._currentDuration = 0;
    
    /**
     * Whether or not the visual of this map action needs removing.
     * @type {boolean}
     */
    this._needsRemoval = false;

    /**
     * The `Game_Event` this `JABS_Action` is bound to. Represents the visual aspect on the map.
     * @type {Game_Event}
     */
    this._actionSprite = null;

    /**
     * The duration remaining before this will action will autotrigger.
     * @type {number}
     */
     this._delayDuration = this._jabsData.delay.duration;

     /**
      * Whether or not this action will trigger when an enemy touches it.
      * @type {boolean}
      */
     this._triggerOnTouch = this._jabsData.delay.touchToTrigger;

    /**
     * The remaining number of times this action can pierce a target.
     * @type {number}
     */
    this._pierceTimesLeft =
      this._jabsData.piercing[0] + this._caster.getAdditionalHits(
        this._baseSkill,
        this._actionCooldownType === Game_Actor.JABS_MAINHAND ||
        this._actionCooldownType === Game_Actor.JABS_OFFHAND);

    /**
     * The base pierce delay in frames.
     * @type {number}
     */
    this._basePierceDelay = this._jabsData.piercing[1];

    /**
     * The current pierce delay in frames.
     * @type {number}
     */
    this._currentPierceDelay = 0;
  };

  /**
   * Gets the `uuid` of this action.
   * 
   * If one is not returned, then it is probably a direct action with no event representing it.
   * @returns {string|null}
   */
  getUuid() {
    return this._uuid;
  };

  /**
   * Gets the base skill this `JABS_Action` is based on.
   * @returns {rm.types.Skill} The base skill of this `JABS_Action`.
   */
  getBaseSkill() {
    return this._baseSkill;
  };

  /**
   * Gets the JABS-specific skill data associated with this action.
   * @returns {JABS_SkillData} This action's JABS skill data object.
   */
  getJabsData() {
    return this._jabsData;
  };

  /**
   * Gets the team id of the caster of this action.
   * @returns {number} The team id of the caster of this `JABS_Action`.
   */
  getTeamId() {
    return this.getCaster().getTeam();
  };

  /**
   * The base game action this `JABS_Action` is based on.
   * @returns {Game_Action} The base game action for this action.
   */
  getAction() {
    return this._gameAction;
  };

  /**
   * Gets the `JABS_Battler` that created this `JABS_Action`.
   * @returns {JABS_Battler} The caster of this `JABS_Action`.
   */
  getCaster() {
    return this._caster;
  };

  /**
   * Whether or not this action is a retaliation- meaning it will not invoke retaliation.
   * @returns {boolean} True if it is a retaliation, false otherwise.
   */
  isRetaliation() {
    return this._isRetaliation;
  };

  /**
   * Gets the direction this action is facing.
   * @returns {2|4|6|8|1|3|7|9}
   */
  direction() {
    return this._facing || this.getActionSprite().direction();
  };

  /**
   * Gets the name of the cooldown for this action.
   * @returns {string} The cooldown key for this action.
   */
  getCooldownType() {
    return this._actionCooldownType;
  };

  /**
   * Sets the name of the cooldown for tracking on the caster.
   * @param {string} type The name of the cooldown that this leverages.
   */
  setCooldownType(type) {
    this._actionCooldownType = type;
  };

  /**
   * Gets the durations remaining on this `JABS_Action`.
   */
  getDuration() {
    return this._currentDuration;
  };

  /**
   * Gets the max duration in frames that this action will exist on the map.
   * If the duration was unset, or is set but less than the minimum, it will be the minimum.
   * @returns {number} The max duration in frames (min 8).
   */
  getMaxDuration() {
    if (this.getJabsData().duration >= JABS_Action.getMinimumDuration()) {
      return this.getJabsData().duration;
    }

    return JABS_Action.getMinimumDuration();
  };

  /**
   * Increments the duration for this `JABS_Action`. If the duration drops
   * to or below 0, then it will also flag this `JABS_Action` for removal.
   */
  countdownDuration() {
    this._currentDuration++;
    if (this.getMaxDuration() <= this._currentDuration) {
      this.setNeedsRemoval();
    }
  };

  /**
   * Gets whether or not this action is expired and should be removed.
   * @returns {boolean} True if expired and past the minimum count, false otherwise.
   */
  isActionExpired() {
    const isExpired = this.getMaxDuration() <= this._currentDuration;
    const minDurationElapsed = this._currentDuration > JABS_Action.getMinimumDuration();
    return (isExpired && minDurationElapsed);
  };

  /**
   * Gets whether or not this `JABS_Action` needs removing.
   * @returns {boolean} Whether or not this action needs removing.
   */
  getNeedsRemoval() {
    return this._needsRemoval;
  };

  /**
   * Sets whether or not this `JABS_Action` needs removing.
   * @param {boolean} remove Whether or not to remove this `JABS_Action`.
   */
  setNeedsRemoval(remove = true) {
    this._needsRemoval = remove;
  };

  /**
   * Gets the `Game_Event` this `JABS_Action` is bound to.
   * The `Game_Event` represents the visual aspect of this action.
   * @returns {Game_Event}
   */
  getActionSprite() {
    return this._actionSprite;
  }

  /**
   * Binds this `JABS_Action` to a provided `Game_Event`.
   * @param {Game_Event} actionSprite The `Game_Event` to bind to this `JABS_Action`.
   */
  setActionSprite(actionSprite) {
    this._actionSprite = actionSprite;
  };

  /**
   * Decrements the pre-countdown delay timer for this action. If the action does not
   * have `touchOnTrigger`, then the action will not affect anyone until the timer expires. 
   */
  countdownDelay() {
    if (this._delayDuration > 0) {
      this._delayDuration--;
    }
  };

  /**
   * Gets whether or not the delay on this action has completed.
   * 
   * This also includes if an action never had a delay to begin with.
   * @returns {boolean}
   */
  isDelayCompleted() {
    return this._delayDuration <= 0 && !this.isEndlessDelay();
  };

  /**
   * Automatically finishes the delay regardless of its current status.
   */
  endDelay() {
    this._delayDuration = 0;
  };

  /**
   * Gets whether or not this action will be delayed until triggered.
   * @returns {boolean}
   */
  isEndlessDelay() {
    return this._delayDuration === -1;
  };

  /**
   * Gets whether or not this action will be triggered by touch, regardless of its
   * delay counter. 
   * 
   * If `isEndlessDelay()` applies to this action, then it will automatically
   * trigger by touch regardless of configuration.
   * @returns {boolean}
   */
  triggerOnTouch() {
    return this._triggerOnTouch || this.isEndlessDelay();
  };

  /**
   * Gets the number of times this action can potentially hit a target.
   * @returns {number} The number of times remaining that this action can hit a target.
   */
  getPiercingTimes() {
    return this._pierceTimesLeft;
  };

  /**
   * Modifies the piercing times counter of this action by an amount (default = 1). If an action
   * reaches zero or less times, then it also sets it up for removal.
   * @param {number} decrement The number to decrement the times counter by for this action. 
   */
  modPiercingTimes(decrement = 1) {
    this._pierceTimesLeft -= decrement;
    if (this._pierceTimesLeft <= 0) {
      this.setNeedsRemoval();
    }
  };

  /**
   * Gets the delay between hits for this action.
   * @returns {number} The number of frames between repeated hits.
   */
  getPiercingDelay() {
    return this._currentPierceDelay;
  };

  /**
   * Modifies the piercing delay by this amount (default = 1). If a negative number is
   * provided, then this will increase the delay by that amount instead.
   * @param {number} decrement The amount to modify the delay by.
   */
  modPiercingDelay(decrement = 1) {
    this._currentPierceDelay -= decrement;
  };

  /**
   * Resets the piercing delay of this action back to it's base.
   */
  resetPiercingDelay() {
    this._currentPierceDelay = this._basePierceDelay;
  };

  /**
   * Gets whether or not this action is a direct-targeting action.
   * @returns {boolean}
   */
  isDirectAction() {
    return this.getJabsData().direct ?? false;
  };

  /**
   * Gets whether or not this action is a support action.
   * @returns {boolean}
   */
  isSupportAction() {
    return this._gameAction.isForFriend();
  };

  /**
   * The number of frames until this action's caster may act again.
   * @returns {number} The cooldown frames of this `JABS_Action`.
   */
  getCooldown() {
    return this.getJabsData().cooldown ?? 0;
  };

  /**
   * Gets the ai-specific cooldown for this skill.
   * This is used in place of regular cooldowns for skills when present.
   * @returns {number}
   */
  getAiCooldown() {
    return this.getJabsData().aiCooldown ?? 0;
  };

  /**
   * Gets the cast time for this skill.
   * @returns {number}
   */
  getCastTime() {
    // TODO: add a cast time modifier based on actor "all notes" collection.
    return this.getJabsData().castTime;
  };

  /**
   * Gets the range of which this `JABS_Action` will reach.
   * @returns {number} The range of this action.
   */
  getRange() {
    // TODO: add ability to increase this (and duration).
    return this.getJabsData().range;
  };

  /**
   * Gets the proximity to the target in order to use this `JABS_Action`.
   * @returns {number} The proximity required for this action.
   */
  getProximity() {
    return this.getJabsData().proximity;
  };

  /**
   * Gets the shape of the hitbox for this `JABS_Action`.
   * @returns {string} The designated shape of the action.
   */
  getShape() {
    return this.getJabsData().shape;
  };

  /**
   * Gets the event id associated with this `JABS_Action` from the action map.
   * @returns {number} The event id for this `JABS_Action`.
   */
  getActionId() {
    return this.getJabsData().actionId;
  };

  /**
   * Gets any additional aggro this skill generates.
   * @returns {number}
   */
  bonusAggro() {
    return this.getJabsData().bonusAggro;
  };

  /**
   * Gets the aggro multiplier from this skill.
   * @returns {number}
   */
  aggroMultiplier() {
    return this.getJabsData().aggroMultiplier;
  };
}
//ENDFILE