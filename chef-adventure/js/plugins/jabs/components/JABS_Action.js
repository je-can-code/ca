/*:
 * @target MZ
 * @plugindesc 
 * [v3.0 JABS] Data structure of an action event generated by the JABS engine.
 * @author JE
 * @url https://github.com/je-can-code/rmmz
 * @base J-ABS
 * @help
 * ============================================================================
 * A component of JABS.
 * This class represents the binding of a skill execution to an event.
 * Effectively, these are generated for each action executed (such as a
 * sword swing or a fireball spell).
 * ============================================================================
 */

/**
 * An object that binds a `Game_Action` to a `Game_Event` and `JABS_Battler`
 * on the map.
 */
class JABS_Action {
  /**
   * The minimum duration a `JABS_Action` must exist visually before cleaning it up.
   * 
   * All actions should exist visually for at least 1/5 of a second.
   */
  static getMinimumDuration = () => 8;

  /**
   * @constructor
   * @param {object} baseSkill The skill retrieved from `$dataSkills[id]`. 
   * @param {number} teamId A shorthand for the team id this skill belongs to.
   * @param {number} cooldownFrames The number of frames until the caster can act again.
   * @param {number} aiCooldownFrames The custom ai-specific cooldown frames for this action, if any.
   * @param {number} range The range of collision for this `JABS_Action`.
   * @param {number} proximity The proximity to the target required for using this `JABS_Action`.
   * @param {Game_Action} gameAction The underlying action associated with this `JABS_Action`.
   * @param {string} shape The shape of the range for this `JABS_Action`.
   * @param {JABS_Battler} caster The `JABS_Battler` who created this `JABS_Action`.
   * @param {number} actionId The id of the skill master map event representing this `JABS_Action`.
   * @param {number} duration The duration in frames of how long this event should exist.
   * @param {array} piercing The piercing data associated with the skill this `JABS_Action` represents.
   * @param {boolean} isRetaliation Whether or not this is a retaliation action.
   * @param {number} direction The direction this action will face initially.
   * @param {boolean} isBasicAttack Whether or not this is a basic attack action.
   * @param {boolean} isSupportAction Whether or not this is a support action for allies.
   * @param {boolean} isDirect Whether or not this is a direct action.
   * @param {{duration: number, touchToTrigger: boolean}} delay The delay data for this action.
   */
  constructor(baseSkill, teamId, cooldownFrames, aiCooldownFrames, range, proximity, shape, 
    gameAction, caster, actionId, duration, piercing, isRetaliation, direction,
    isBasicAttack, isSupportAction, isDirect, delay) {
      /**
       * The base skill object, in case needed for something.
       * @type {object}
       */
      this._baseSkill = baseSkill;

      /**
       * The team the owner of this skill is a part of.
       * @type {number}
       */
      this._teamId = teamId;

      /**
       * The number of frames before the battler using this action can act again.
       * @type {number}
       */
      this._cooldownFrames = cooldownFrames;

      /**
       * The number of frames before the battler using this action can act again.
       * This is typically used to overwrite long-cooldown skills that the AI doesn't
       * have to obey. If the value for this is `-1`, then this will be ignored.
       * @type {number}
       */
      this._aiCooldownFrames = aiCooldownFrames;

      /**
       * The range of collision for this action.
       * @type {number}
       */
      this._range = range;

      /**
       * The proximity required to use this skill.
       */
      this._proximity = proximity;

      /**
       * The shape of this action.
       * @type {string}
       */
      this._shape = shape;

      /**
       * The `Game_Action` to bind to the `Game_Event` and `JABS_Battler`.
       * @type {Game_Action}
       */
      this._gameAction = gameAction;

      /**
       * The `JABS_Battler` that used created this `JABS_Action`. 
       * @type {JABS_Battler}
       */
      this._caster = caster;
      
      /**
       * The id of the event that maps to this skill from the skill master map.
       * @type {number}
       */
      this._actionId = actionId;

      /**
       * The duration in frames for how long this event should last on
       * the battle map.
       * @type {number}
       */
      this._maxDuration = duration;

      /**
       * The object that defines the various properties associated with "piercing" for this `JABS_Action`.
       * `times` = if piercing, then this represents how many times this action can repeatedly hit.
       * `delay` = the number of frames between each individual hit for this action.
       * @type {any} Including properties: `times`, and `delay`.
       */
      this._piercingData = this.initPiercingData(piercing[0]);

      /**
       * The base pierce delay in frames.
       * @type {number}
       */
      this._basePierceDelay = piercing[1];

      /**
       * Whether or not this action was generated as a retaliation to another battler's action.
       * @type {boolean}
       */
      this._isRetaliation = isRetaliation;

      /**
       * The direction this projectile will initially face and move.
       * @type {number}
       */
      this._facing = direction;

      /**
       * Whether or not this action was generated from a mainhand or offhand skill.
       * @type {boolean}
       */
      this._isBasicAttack = isBasicAttack;

      /**
       * Whether or not this action is a support type skill, for targeting allies.
       * @type {boolean}
       */
      this._isSupportAction = isSupportAction;

      /**
       * Whether or not this action is a direct-targeting skill, for bypassing projectile movement.
       * @type {boolean}
       */
      this._isDirect = isDirect;

      /**
       * The duration remaining before this will action will autotrigger.
       * @type {number}
       */
      this._delayDuration = delay.duration;

      /**
       * Whether or not this action will trigger when an enemy touches it.
       * @type {boolean}
       */
      this._triggerOnTouch = delay.touchToTrigger;
      this.initialize();
  }

  /**
   * Initializes all properties that don't require input parameters.
   */
  initialize = () => {
      /**
       * The type of action this is. Used for mapping cooldowns to the appropriate slot on the caster.
       * @type {string}
       */
      this._actionCooldownType = "global";
      
      /**
       * Whether or not this action has already begun animating.
       * @type {boolean}
       */
      this._animating = {};
      
      /**
       * The current timer on this particular action.
       * @type {number}
       */
      this._currentDuration = 0;
      
      /**
       * Whether or not the visual of this map action needs rendering.
       * @type {boolean}
       */
      this._needsCreation = true;
      
      /**
       * Whether or not the visual of this map action needs removing.
       * @type {boolean}
       */
      this._needsRemoval = false;

      /**
       * The `Game_Event` this `JABS_Action` is bound to. Represents the visual aspect on the map.
       * @type {Game_Event}
       */
      this._actionSprite = null;

      /**
       * Whether or not this action has had it's cooldown checked from a previous pierced hit.
       * @type {boolean}
       */
      this._cooldownChecked = false;
  }

  /**
   * Initializes the piercing data for this action.
   * @param {number} times The number of times this action can pierce the target.
   * @returns {{times: number, delay: number}}
   */
  initPiercingData = times => {
    return {
      times,
      delay: 0,
    };
  };

  /**
   * Gets whether or not this action is a direct-targeting action.
   * @returns {boolean}
   */
  isDirectAction = () => this._isDirect;

  /**
   * Gets whether or not this action is a support action.
   * @returns {boolean}
   */
  isSupportAction = () => this._isSupportAction;

  /**
   * Sets whether or not this action is currently animating against the target.
   * @param {string} targetKey The target's `uuid`.
   * @param {boolean} animating True if it is currently animating, false otherwise.
   */
  setAnimating = (targetKey, animating) => {
    this._animating[targetKey] = animating;
  };

  /**
   * Gets the name of the cooldown for this action.
   */
  getCooldownType = () => this._actionCooldownType;

  /**
   * Sets the name of the cooldown for tracking on the caster.
   * @param {string} type The name of the cooldown that this leverages.
   */
  setCooldownType = type => this._actionCooldownType = type;

  /**
   * Gets the base skill this `JABS_Action` is based on.
   * @returns {any} The base skill of this `JABS_Action`.
   */
  getBaseSkill = () => this._baseSkill;

  /**
   * A shorthand to retrieve this `JABS_Action`'s team it belongs to.
   * @returns {number} The team id of the caster of this `JABS_Action`.
   */
  getTeamId = () => this._teamId;

  /**
   * The number of frames until the caster of this `JABS_Action` may act again.
   * @returns {number} The cooldown frames of this `JABS_Action`.
   */
  getCooldown = () => {
    return this._cooldownFrames;
  };

  /**
   * Gets the ai-specific cooldown for this skill.
   * This overwrites the basic cooldown value if it is greater than `-1`.
   * @returns {number}
   */
  getAiCooldown = () => {
    return this._aiCooldownFrames;
  };

  /**
   * Gets the cast time for this skill.
   * @returns {number}
   */
  getCastTime = () => {
    const skill = this.getBaseSkill();
    return skill._j.castTime;
  }

  /**
   * Gets the range of which this `JABS_Action` will reach.
   * @returns {number} The range of this action.
   */
  getRange = () => this._range;

  /**
   * Gets the proximity to the target in order to use this `JABS_Action`.
   * @returns {number} The proximity required for this action.
   */
  getProximity = () => this._proximity;

  /**
   * The shape of the hitbox for this `JABS_Action`.
   */
  getShape = () => this._shape;

  /**
   * The base game action this `JABS_Action` is based on.
   * @returns {Game_Action} The base game action for this action.
   */
  getAction = () => this._gameAction;

  /**
   * Gets the `JABS_Battler` that created this `JABS_Action`.
   * @returns {JABS_Battler} The caster of this `JABS_Action`.
   */
  getCaster = () => this._caster;

  /**
   * Gets the event id associated with this `JABS_Action` from the action map.
   * @returns {number} The event id for this `JABS_Action`.
   */
  getActionId = () => this._actionId;

  /**
   * Gets the number of times this action can potentially hit a target.
   * @returns {number} The number of times remaining that this action can hit a target.
   */
  getPiercingTimes = () => this._piercingData.times;

  /**
   * Modifies the piercing times counter of this action by an amount (default = 1). If an action
   * reaches zero or less times, then it also sets it up for removal.
   * @param {number} decrement The number to decrement the times counter by for this action. 
   */
  modPiercingTimes = (decrement = 1) => {
    this._piercingData.times -= decrement;
    if (this._piercingData.times <= 0) {
      this.setNeedsRemoval();
    }
  };

  /**
   * Gets the delay between hits for this action.
   * @returns {number} The number of frames between repeated hits.
   */
  getPiercingDelay = () => this._piercingData.delay;

  /**
   * Modifies the piercing delay by this amount (default = 1). If a negative number is
   * provided, then this will increase the delay by that amount instead.
   * @param {number} decrement The amount to modify the delay by.
   */
  modPiercingDelay = (decrement = 1) => this._piercingData.delay -= decrement;

  /**
   * Resets the piercing delay of this action back to it's base.
   */
  resetPiercingDelay = () => this._piercingData.delay = this._basePierceDelay;

  /**
   * Gets whether or not this `JABS_Action` needs rendering.
   * @returns {boolean} Whether or not this action needs rendering.
   */
  getNeedsCreation = () => this._needsCreation;

  /**
   * Gets whether or not this `JABS_Action` needs removing.
   * @returns {boolean} Whether or not this action needs removing.
   */
  getNeedsRemoval = () => this._needsRemoval;

  /**
   * Sets whether or not this `JABS_Action` needs removing.
   * @param {boolean} remove Whether or not to remove this `JABS_Action`.
   */
  setNeedsRemoval = (remove = true) => this._needsRemoval = remove;

  /**
   * Gets the durations remaining on this `JABS_Action`.
   */
  getDuration = () => this._currentDuration;

  /**
   * Increments the duration for this `JABS_Action`. If the duration drops
   * to or below 0, then it will also flag this `JABS_Action` for removal.
   */
  countdownDuration = () => {
    this._currentDuration++;
    if (this._maxDuration <= this._currentDuration) {
      this.setNeedsRemoval();
    }
  };

  /**
   * Gets whether or not this action is expired and should be removed.
   * @returns {boolean} True if expired and past the minimum count, false otherwise.
   */
  isActionExpired = () => {
    const isExpired = this._maxDuration <= this._currentDuration;
    const minDurationElapsed = this._currentDuration > JABS_Action.getMinimumDuration();
    return (isExpired && minDurationElapsed);
  };

  /**
   * Decrements the pre-countdown delay timer for this action. If the action does not
   * have `touchOnTrigger`, then the action will not affect anyone until the timer expires. 
   */
  countdownDelay = () => {
    if (this._delayDuration > 0) {
      this._delayDuration--;
    }
  };

  /**
   * Gets whether or not the delay on this action has completed.
   * 
   * This also includes if an action never had a delay to begin with.
   * @returns {boolean}
   */
  isDelayCompleted = () => {
    return this._delayDuration <= 0 && !this.isEndlessDelay();
  };

  /**
   * Automatically finishes the delay regardless of its current status.
   */
  endDelay = () => {
    this._delayDuration = 0;
  };

  /**
   * Gets whether or not this action will be delayed until triggered.
   * @returns {boolean}
   */
  isEndlessDelay = () => {
    return this._delayDuration === -1;
  };

  /**
   * Gets whether or not this action will be triggered by touch, regardless of its
   * delay counter. 
   * 
   * If `isEndlessDelay()` applies to this action, then it will automatically
   * trigger by touch regardless of configuration.
   * @returns {boolean}
   */
  triggerOnTouch = () => {
    return this._triggerOnTouch || this.isEndlessDelay();
  };

  /**
   * Gets the `Game_Event` this `JABS_Action` is bound to.
   * The `Game_Event` represents the visual aspect of this action.
   * @returns {Game_Event}
   */
  getActionSprite = () => this._actionSprite;

  /**
   * Binds this `JABS_Action` to a provided `Game_Event`.
   * @param {Game_Event} actionSprite The `Game_Event` to bind to this `JABS_Action`.
   */
  setActionSprite = actionSprite => this._actionSprite = actionSprite;

  /**
   * Whether or not this action is a retaliation- meaning it will not invoke retaliation.
   * @returns {boolean} True if it is a retaliation, false otherwise.
   */
  get isRetaliation() {
    return this._isRetaliation;
  };

  /**
   * Gets the direction this action is facing.
   */
  get direction() {
    return this._facing || this.getActionSprite().direction();
  };

  /**
   * Gets any additional aggro this skill generates.
   * @returns {number}
   */
  get bonusAggro() {
    return this.getBaseSkill()._j.bonusAggro;
  };

  /**
   * Gets the aggro multiplier from this skill.
   * @returns {number}
   */
  get aggroMultiplier() {
    return this.getBaseSkill()._j.aggroMultiplier;
  };
}
//ENDFILE